{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Modaic Docs","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Install Modaic</p> <pre><code>uv install modaic\n</code></pre>"},{"location":"#modaic-principles","title":"Modaic Principles","text":"<p>In Modaic there are two types of context. <code>Molecular</code> and <code>Atomic</code>. Molecular context is</p>"},{"location":"#create-a-simple-rag-framework","title":"Create a Simple RAG Framework","text":"<p>Lets create a simple agent that can answer questions about the weather.</p> <pre><code>from modaic import PrecompiledAgent, PrecompiledConfig\n\nclass WeatherConfig(PrecompiledConfig):\n    agent_type = \"WeatherAgent\" # !! This is super important so you can load the agent later!!\n\nclass WeatherAgent(PrecompiledAgent):\n    config_class = WeatherConfig # !! This is super important to link the agent to the config!!\n    def __init__(self, config: WeatherConfig, **kwargs):\n        super().__init__(config, **kwargs)\n\n    def forward(self, query: str) -&gt; str:\n        return self.get_weather(query)\n\n    def get_weather(self, city: str) -&gt; str:\n        return f\"The weather in {city} is sunny.\"\n\nagent = WeatherAgent(PrecompiledAgentConfig())\nagent.forward(\"What is the weather in Tokyo?\")\n</code></pre>"},{"location":"#defining-your-own-context","title":"Defining your own context","text":""},{"location":"reference/precompiled_agent/","title":"PrecompiledAgent","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent","title":"<code>modaic.precompiled_agent.PrecompiledAgent(config: PrecompiledConfig, **kwargs)</code>","text":"<p>Bases: <code>dspy.Module</code></p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def __init__(self, config: PrecompiledConfig, **kwargs):\n    self.config = config\n    assert config.agent_type == self.__class__.__name__, (\n        f\"Config agent_type must match agent class name. Expected {self.__class__.__name__}, got {config.agent_type}\"\n    )\n    assert isinstance(config, self.config_class), (\n        f\"Config must be an instance of {self.config_class.__name__}\"\n    )\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent-functions","title":"Functions","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.forward","title":"<code>forward(**kwargs) -&gt; str</code>","text":"<p>Forward pass for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Forward pass result.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def forward(self, **kwargs) -&gt; str:\n    \"\"\"\n    Forward pass for the agent.\n\n    Args:\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Forward pass result.\n    \"\"\"\n    raise NotImplementedError(\n        \"Forward pass for PrecompiledAgent is not implemented. You must implement a forward method in your subclass.\"\n    )\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the agent and the config to the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the agent and config to. Must be a local path.</p> required Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def save_precompiled(self, path: str) -&gt; None:\n    \"\"\"\n    Saves the agent and the config to the given path.\n\n    Args:\n        path: The path to save the agent and config to. Must be a local path.\n    \"\"\"\n    path = pathlib.Path(path)\n    path.mkdir(parents=True, exist_ok=True)\n    self.config.save_precompiled(path)\n    self.save(path / \"agent.json\")\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.from_precompiled","title":"<code>from_precompiled(path: str, **kwargs) -&gt; PrecompiledAgent</code>  <code>classmethod</code>","text":"<p>Loads the agent and the config from the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the agent and config from. Can be a local path or a path on Modaic Hub.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PrecompiledAgent</code> <p>An instance of the PrecompiledAgent class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_precompiled(cls, path: str, **kwargs) -&gt; \"PrecompiledAgent\":\n    \"\"\"\n    Loads the agent and the config from the given path.\n\n    Args:\n        path: The path to load the agent and config from. Can be a local path or a path on Modaic Hub.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        An instance of the PrecompiledAgent class.\n    \"\"\"\n    assert cls.config_class is not None, (\n        f\"Config class must be set for {cls.__name__}. \\nHint: PrecompiledAgent.from_precompiled(path) will not work. You must use a subclass of PrecompiledAgent.\"\n    )\n    path = pathlib.Path(path)\n    config = cls.config_class.from_precompiled(path)\n    agent = cls(config, **kwargs)\n    return agent\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.push_to_hub","title":"<code>push_to_hub(repo_id: str) -&gt; None</code>","text":"<p>Pushes the agent and the config to the given repo_id.</p> <p>Parameters:</p> Name Type Description Default <code>repo_id</code> <code>str</code> <p>The path on Modaic hub to save the agent and config to.</p> required Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def push_to_hub(self, repo_id: str) -&gt; None:\n    \"\"\"\n    Pushes the agent and the config to the given repo_id.\n\n    Args:\n        repo_id: The path on Modaic hub to save the agent and config to.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig","title":"<code>modaic.precompiled_agent.PrecompiledConfig(**kwargs)</code>","text":"Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def __init__(self, **kwargs):\n    for k, v in kwargs.items():\n        try:\n            setattr(self, k, v)\n        except AttributeError as e:\n            print(\n                f\"Warning: {k} is not a valid attribute for {self.__class__.__name__}\"\n            )\n            raise e\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig-functions","title":"Functions","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the config to a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the config to.</p> required Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def save_precompiled(self, path: str) -&gt; None:\n    \"\"\"\n    Saves the config to a config.json file in the given path.\n\n    Args:\n        path: The path to save the config to.\n    \"\"\"\n    print(self.__dict__)\n    print(self.agent_type)\n    path = pathlib.Path(path)\n    path.mkdir(parents=True, exist_ok=True)\n    with open(path / \"config.json\", \"w\") as f:\n        json.dump(self.__dict__, f, indent=2)\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_precompiled","title":"<code>from_precompiled(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_precompiled(cls, path: str) -&gt; \"PrecompiledConfig\":\n    \"\"\"\n    Loads the config from a config.json file in the given path.\n\n    Args:\n        path: The path to load the config from.\n\n    Returns:\n        An instance of the PrecompiledConfig class.\n    \"\"\"\n    path = pathlib.Path(path) / \"config.json\"\n    with open(path, \"r\") as f:\n        config_dict = json.load(f)\n        return cls(**config_dict)\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_dict","title":"<code>from_dict(dict: Dict) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <code>Dict</code> <p>A dictionary containing the config.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_dict(cls, dict: Dict) -&gt; \"PrecompiledConfig\":\n    \"\"\"\n    Loads the config from a dictionary.\n\n    Args:\n        dict: A dictionary containing the config.\n\n    Returns:\n        An instance of the PrecompiledConfig class.\n    \"\"\"\n    instance = cls(**dict)\n    return instance\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_json","title":"<code>from_json(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_json(cls, path: str) -&gt; \"PrecompiledConfig\":\n    \"\"\"\n    Loads the config from a json file.\n\n    Args:\n        path: The path to load the config from.\n\n    Returns:\n        An instance of the PrecompiledConfig class.\n    \"\"\"\n    with open(path, \"r\") as f:\n        return cls.from_dict(json.load(f))\n</code></pre>"},{"location":"reference/context/table/","title":"Table","text":"<p>handler: python</p> <p>handler: python</p>"},{"location":"reference/context/table/#modaic.context.table.Table","title":"<code>modaic.context.table.Table(df: pd.DataFrame, name: str, prepare_for_sql: bool = True, **kwargs)</code>","text":"<p>               Bases: <code>Molecular</code></p> <p>A molecular context object that represents a table. Can be queried with SQL.</p> <p>Initializes a Table context object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to represent as a table.</p> required <code>name</code> <code>str</code> <p>The name of the table.</p> required <code>prepare_for_sql</code> <code>bool</code> <p>Whether to prepare the table for SQL queries.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Molecular context object.</p> <code>{}</code> Source code in <code>src/modaic/context/table.py</code> <pre><code>def __init__(\n    self, df: pd.DataFrame, name: str, prepare_for_sql: bool = True, **kwargs\n):\n    \"\"\"\n    Initializes a Table context object.\n\n    Args:\n        df: The dataframe to represent as a table.\n        name: The name of the table.\n        prepare_for_sql: Whether to prepare the table for SQL queries.\n        **kwargs: Additional keyword arguments to pass to the Molecular context object.\n    \"\"\"\n    super().__init__(**kwargs)\n    self._df = df\n    self.name = name\n    self.prepare_for_sql = prepare_for_sql\n\n    if prepare_for_sql:\n        self.sanitize_columns()\n        if not is_valid_table_name(name):\n            self.name = Table.sanitize_name(name)\n            warnings.warn(\n                f\"Table name {name} is not a valid SQL table name and has been sanitized to {self.name}. To keep the original name, initialize with `prepare_for_sql=False`\"\n            )\n    self._chunks = []\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table-functions","title":"Functions","text":""},{"location":"reference/context/table/#modaic.context.table.Table.get_col","title":"<code>get_col(col_name: str) -&gt; pd.Series</code>","text":"<p>Gets a single column from the table.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the column to get</p> required <p>Returns:</p> Type Description <code>Series</code> <p>The specified column as a pandas Series.</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def get_col(self, col_name: str) -&gt; pd.Series:\n    \"\"\"\n    Gets a single column from the table.\n\n    Args:\n        col_name: Name of the column to get\n\n    Returns:\n        The specified column as a pandas Series.\n    \"\"\"\n    return self._df[col_name]\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.query","title":"<code>query(query: str)</code>","text":"<p>Queries the table. All queries run should refer to the table as <code>this</code> or <code>This</code></p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def query(self, query: str):\n    \"\"\"\n    Queries the table. All queries run should refer to the table as `this` or `This`\n    \"\"\"\n    return duckdb.query_df(self._df, \"this\", query).to_df()\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.to_markdown","title":"<code>to_markdown() -&gt; str</code>","text":"<p>Converts the table to markdown format. Returns a markdown representation of the table with the table name as header.</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def to_markdown(self) -&gt; str:\n    \"\"\"\n    Converts the table to markdown format.\n    Returns a markdown representation of the table with the table name as header.\n    \"\"\"\n    content = \"\"\n    content += f\"Table name: {self.name}\\n\"\n\n    # Add header row\n    columns = [str(col) for col in self._df.columns]\n    content += \" | \" + \" | \".join(columns) + \" | \\n\"\n\n    # Add header separator\n    content += \" | \" + \" | \".join([\"---\"] * len(columns)) + \" | \\n\"\n\n    # Add data rows\n    for _, row in self._df.iterrows():\n        row_values = []\n        for value in row:\n            if pd.isna(value) or value is None:\n                row_values.append(\"\")\n            else:\n                row_values.append(str(value))\n        content += \" | \" + \" | \".join(row_values) + \" | \\n\"\n\n    return content\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable","title":"<code>modaic.context.table.MultiTabbedTable(tables: dict[str, Table], **kwargs)</code>","text":"<p>               Bases: <code>Molecular</code></p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def __init__(self, tables: dict[str, Table], **kwargs):\n    super().__init__(**kwargs)\n    self.tables = tables\n    self.sql_db = None\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable-functions","title":"Functions","text":""},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.init_sql","title":"<code>init_sql()</code>","text":"<p>Initilizes and in memory sql database for querying</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def init_sql(self):\n    \"\"\"\n    Initilizes and in memory sql database for querying\n    \"\"\"\n    self.sql_db = duckdb.connect(database=\":memory:\")\n    for table_name, table in self.tables.items():\n        self.sql_db.register(table_name, table.df)\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.close_sql","title":"<code>close_sql()</code>","text":"<p>Closes the in memory sql database</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def close_sql(self):\n    \"\"\"\n    Closes the in memory sql database\n    \"\"\"\n    self.sql_db.close()\n    self.sql_db = None\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.query","title":"<code>query(query: str)</code>","text":"<p>Queries the in memory sql database</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def query(self, query: str):\n    \"\"\"\n    Queries the in memory sql database\n    \"\"\"\n    if self.sql_db is None:\n        raise ValueError(\n            \"Attempted to run query on MultiTabbedTable without initializing the SQL database. Use with `with MultiTabbedTable.sql():` or `MultiTabbedTable.init_sql()`\"\n        )\n    try:\n        df = self.sql_db.execute(query).fetchdf()\n        return Table(\n            df=df, name=\"query_result\", source=Source(self, SourceType.OBJECT)\n        )\n    except Exception as e:\n        raise ValueError(f\"Error querying SQL database: {e}\")\n</code></pre>"},{"location":"reference/databases/sql_database/","title":"SQL Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase","title":"<code>modaic.databases.sql_database.SQLDatabase(config: SQLDatabaseConfig | str, engine_kwargs: dict = {}, session_kwargs: dict = {})</code>","text":"<p>               Bases: <code>ContextDatabase</code></p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def __init__(\n    self,\n    config: SQLDatabaseConfig | str,\n    engine_kwargs: dict = {},  # TODO: This may not be a smart idea, may want to enforce specific kwargs\n    session_kwargs: dict = {},  # TODO: This may not be a smart idea\n):\n    self.url = config.url if isinstance(config, SQLDatabaseConfig) else config\n    self.engine = create_engine(self.url, **engine_kwargs)\n    self.metadata = MetaData()\n    self.session = sessionmaker(bind=self.engine, **session_kwargs)\n    self.inspector = inspect(self.engine)\n\n    # Create metadata table to store table metadata\n    self.metadata_table = SQLTable(\n        \"metadata\",\n        self.metadata,\n        Column(\"table_name\", String(255), primary_key=True),\n        Column(\"metadata_json\", Text),\n    )\n    self.metadata.create_all(self.engine)\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase-functions","title":"Functions","text":""},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.drop_table","title":"<code>drop_table(name: str)</code>","text":"<p>Drop a table from the database and remove its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to drop</p> required Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def drop_table(self, name: str):\n    \"\"\"\n    Drop a table from the database and remove its metadata.\n\n    Args:\n        name: The name of the table to drop\n    \"\"\"\n    with self.engine.connect() as conn:\n        conn.execute(f\"DROP TABLE IF EXISTS {name}\")\n        # Also remove metadata for this table\n        conn.execute(\n            self.metadata_table.delete().where(\n                self.metadata_table.c.table_name == name\n            )\n        )\n        conn.commit()\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.list_tables","title":"<code>list_tables()</code>","text":"<p>List all tables currently in the database.</p> <p>Returns:</p> Type Description <p>List of table names in the database.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def list_tables(self):\n    \"\"\"\n    List all tables currently in the database.\n\n    Returns:\n        List of table names in the database.\n    \"\"\"\n    return self.inspector.get_table_names()\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_schema","title":"<code>get_table_schema(name: str)</code>","text":"<p>Return column schema for a given table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get schema for</p> required <p>Returns:</p> Type Description <p>Column schema information for the table.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def get_table_schema(self, name: str):\n    \"\"\"\n    Return column schema for a given table.\n\n    Args:\n        name: The name of the table to get schema for\n\n    Returns:\n        Column schema information for the table.\n    \"\"\"\n    return self.inspector.get_columns(name)\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_metadata","title":"<code>get_table_metadata(name: str) -&gt; dict</code>","text":"<p>Get metadata for a specific table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get metadata for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the table's metadata, or empty dict if not found.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def get_table_metadata(self, name: str) -&gt; dict:\n    \"\"\"\n    Get metadata for a specific table.\n\n    Args:\n        name: The name of the table to get metadata for\n\n    Returns:\n        Dictionary containing the table's metadata, or empty dict if not found.\n    \"\"\"\n    with self.engine.connect() as conn:\n        result = conn.execute(\n            self.metadata_table.select().where(\n                self.metadata_table.c.table_name == name\n            )\n        ).fetchone()\n\n        if result:\n            return json.loads(result.metadata_json)\n        return {}\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.from_dir","title":"<code>from_dir(dir_path: str, config: SQLDatabaseConfig)</code>  <code>classmethod</code>","text":"<p>Initializes a new SQLDatabase from a directory of files.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>Path to the directory containing files to load</p> required <code>config</code> <code>SQLDatabaseConfig</code> <p>SQL database configuration</p> required <p>Returns:</p> Type Description <p>New SQLDatabase instance loaded with data from the directory.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>@classmethod\ndef from_dir(cls, dir_path: str, config: SQLDatabaseConfig):\n    # TODO: support batch inserting and parallel processing\n    \"\"\"\n    Initializes a new SQLDatabase from a directory of files.\n\n    Args:\n        dir_path: Path to the directory containing files to load\n        config: SQL database configuration\n\n    Returns:\n        New SQLDatabase instance loaded with data from the directory.\n    \"\"\"\n    # TODO: make sure the loaded sql database is empty if not raise error and tell user to use __init__ for an already existing database\n    instance = cls(config)\n    if not os.path.exists(dir_path):\n        raise FileNotFoundError(f\"File not found: {dir_path}\")\n    for file_name in tqdm(\n        os.listdir(dir_path), desc=\"Uploading files to SQL database\"\n    ):\n        full_path = os.path.join(dir_path, file_name)\n        if file_name.endswith(\".xlsx\") or file_name.endswith(\".xls\"):\n            table = Table.from_excel(full_path)\n            instance.add_table(table, if_exists=\"fail\")\n        elif file_name.endswith(\".csv\"):\n            table = Table.from_csv(full_path)\n            instance.add_table(table, if_exists=\"fail\")\n    return instance\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLServerConfig","title":"<code>modaic.databases.sql_database.SQLServerConfig(user: str, password: str, host: str, database: str, port: Optional[str] = None, dialect: str = 'mysql', driver: Optional[str] = None, query_params: Optional[dict] = None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SQLDatabaseConfig</code></p> <p>Configuration for a SQL served over a port or remote connection. (MySQL, PostgreSQL, etc.)</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The username to connect to the database.</p> required <code>password</code> <code>str</code> <p>The password to connect to the database.</p> required <code>host</code> <code>str</code> <p>The host of the database.</p> required <code>database</code> <code>str</code> <p>The name of the database.</p> required <code>port</code> <code>Optional[str]</code> <p>The port of the database.</p> <code>None</code>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLiteConfig","title":"<code>modaic.databases.sql_database.SQLiteConfig(db_path: Optional[str] = None, in_memory: bool = False, query_params: Optional[dict] = None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SQLDatabaseConfig</code></p> <p>Configuration for a SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Optional[str]</code> <p>Path to the SQLite database file.</p> <code>None</code> <code>in_memory</code> <code>bool</code> <p>Whether to create an in-memory SQLite database.</p> <code>False</code> <code>query_params</code> <code>Optional[dict]</code> <p>Query parameters to pass to the database.</p> <code>None</code>"},{"location":"reference/databases/vector_database/","title":"Vector Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase","title":"<code>modaic.databases.vector_database.VectorDatabase(config: VectorDatabaseConfig, embedder: dspy.Embedder, metadata_schema: Type[BaseModel] = None, **kwargs)</code>","text":"<p>Initialize a vanilla vector database. This is a base class for all vector databases. If you need more functionality from a specific vector database, you should use a specific subclass.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>VectorDatabaseConfig</code> <p>The configuration for the vector database</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder to use for the vector database</p> required <code>metadata_schema</code> <code>Type[BaseModel]</code> <p>The Pydantic schema for validating context metadata</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def __init__(\n    self,\n    config: VectorDatabaseConfig,\n    embedder: dspy.Embedder,\n    metadata_schema: Type[BaseModel] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a vanilla vector database. This is a base class for all vector databases. If you need more functionality from a specific vector database, you should use a specific subclass.\n\n    Args:\n        config: The configuration for the vector database\n        embedder: The embedder to use for the vector database\n        metadata_schema: The Pydantic schema for validating context metadata\n        **kwargs: Additional keyword arguments\n    \"\"\"\n    self.config = config\n    self.embedder = embedder\n    self.metadata_schema = metadata_schema\n\n    # CAVEAT: this loads a module from /integrations, which implements custom logic for a specific vector database provider.\n    # CAVEAT It should be noted that some functions will raise NotImplementedErrors if the provider does not support the functionality.\n    try:\n        self.module = importlib.import_module(config._module)\n    except ImportError as e:\n        raise ImportError(f\"\"\"Unable to use the {config._module}, integration. Please make sure to install the module as an extra dependency for modaic.\n                          You can install the module by running: pip install modaic[{config._module}]\n                          OriginalError: {e}\"\"\")\n    self.client = self.module.init(config)\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase-functions","title":"Functions","text":""},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.create_collection","title":"<code>create_collection(collection_name: str, metadata_schema: Type[BaseModel], exists_behavior: Literal['fail', 'replace', 'append'] = 'replace')</code>","text":"<p>Create a collection in the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create</p> required <code>metadata_schema</code> <code>Type[BaseModel]</code> <p>The schema of the collection</p> required <code>exists_behavior</code> <code>Literal['fail', 'replace', 'append']</code> <p>The behavior when the collection already exists</p> <code>'replace'</code> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def create_collection(\n    self,\n    collection_name: str,\n    metadata_schema: Type[BaseModel],\n    exists_behavior: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n):\n    \"\"\"\n    Create a collection in the vector database.\n\n    Args:\n        collection_name: The name of the collection to create\n        metadata_schema: The schema of the collection\n        exists_behavior: The behavior when the collection already exists\n    \"\"\"\n    # Check if collection exists\n    collection_exists = self.module.has_collection(self.client, collection_name)\n\n    if collection_exists:\n        if exists_behavior == \"fail\":\n            raise ValueError(\n                f\"Collection '{collection_name}' already exists and exists_behavior is set to 'fail'\"\n            )\n        elif exists_behavior == \"replace\":\n            self.module.drop_collection(self.client, collection_name)\n        elif exists_behavior == \"append\":\n            # If appending, just return as collection already exists\n            return\n\n    # Create the collection\n    self.module.create_collection(self.client, collection_name, metadata_schema)\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.add_records","title":"<code>add_records(collection_name: str, records: Iterable[Context | Tuple[str, SerializedContext]], batch_size: Optional[int] = None)</code>","text":"<p>Add items to a collection in the vector database. Uses the Context's get_embed_context() method and the embedder to create embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to add records to</p> required <code>records</code> <code>Iterable[Context | Tuple[str, SerializedContext]]</code> <p>The records to add to the collection</p> required <code>batch_size</code> <code>Optional[int]</code> <p>Optional batch size for processing records</p> <code>None</code> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def add_records(\n    self,\n    collection_name: str,\n    records: Iterable[Context | Tuple[str, SerializedContext]],\n    batch_size: Optional[int] = None,\n):\n    \"\"\"\n    Add items to a collection in the vector database.\n    Uses the Context's get_embed_context() method and the embedder to create embeddings.\n\n    Args:\n        collection_name: The name of the collection to add records to\n        records: The records to add to the collection\n        batch_size: Optional batch size for processing records\n    \"\"\"\n    if not records:\n        return\n\n    # Extract embed contexts from all items\n    embedmes = []\n    serialized_contexts = []\n\n    for i, item in enumerate(records):\n        match item:\n            case Context() as context:\n                embedme = context.embedme()\n                embedmes.append(embedme)\n                serialized_contexts.append(context.serialize())\n            case (str() as embedme, SerializedContext() as serialized_context):\n                embedmes.append(embedme)\n                serialized_contexts.append(serialized_context)\n            case _:\n                raise ValueError(\n                    f\"Unsupported VectorDatabase record format: {item}\"\n                )\n\n        if batch_size is not None and i % batch_size == 0:\n            self._embed_and_add_records(\n                collection_name, embedmes, serialized_contexts\n            )\n            embedmes = []\n            serialized_contexts = []\n\n    if embedmes:\n        self._embed_and_add_records(collection_name, embedmes, serialized_contexts)\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.search","title":"<code>search(collection_name: str, vector: np.ndarray | List[int], k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Retrieve records from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to search</p> required <code>vector</code> <code>ndarray | List[int]</code> <p>The vector to search with</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the search</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the search.</p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def search(\n    self,\n    collection_name: str,\n    vector: np.ndarray | List[int],\n    k: int = 10,\n    filter: Optional[dict] = None,\n) -&gt; List[SerializedContext]:\n    \"\"\"\n    Retrieve records from the vector database.\n\n    Args:\n        collection_name: The name of the collection to search\n        vector: The vector to search with\n        k: The number of results to return\n        filter: Optional filter to apply to the search\n\n    Returns:\n        List of serialized contexts matching the search.\n    \"\"\"\n    return self.module.retrieve(self.client, collection_name, vector, k, filter)\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.get_record","title":"<code>get_record(collection_name: str, record_id: str) -&gt; SerializedContext</code>","text":"<p>Get a record from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection</p> required <code>record_id</code> <code>str</code> <p>The ID of the record to retrieve</p> required <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context record.</p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def get_record(self, collection_name: str, record_id: str) -&gt; SerializedContext:\n    \"\"\"\n    Get a record from the vector database.\n\n    Args:\n        collection_name: The name of the collection\n        record_id: The ID of the record to retrieve\n\n    Returns:\n        The serialized context record.\n    \"\"\"\n    raise NotImplementedError(\n        \"get_record is not implemented for this vector database\"\n    )\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.query","title":"<code>query(query: str, k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Query the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the query</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the query.</p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def query(\n    self, query: str, k: int = 10, filter: Optional[dict] = None\n) -&gt; List[SerializedContext]:\n    \"\"\"\n    Query the vector database.\n\n    Args:\n        query: The query string\n        k: The number of results to return\n        filter: Optional filter to apply to the query\n\n    Returns:\n        List of serialized contexts matching the query.\n    \"\"\"\n    raise NotImplementedError(\"query is not implemented for this vector database\")\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.print_available_functions","title":"<code>print_available_functions(config_type: Type[VectorDatabaseConfig])</code>  <code>staticmethod</code>","text":"<p>Print the available functions for a given vector database configuration type.</p> <p>Parameters:</p> Name Type Description Default <code>config_type</code> <code>Type[VectorDatabaseConfig]</code> <p>The vector database configuration type to check</p> required Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>@staticmethod\ndef print_available_functions(config_type: Type[VectorDatabaseConfig]):\n    \"\"\"\n    Print the available functions for a given vector database configuration type.\n\n    Args:\n        config_type: The vector database configuration type to check\n    \"\"\"\n    module = importlib.import_module(config_type._module)\n    print(f\"Available functions for {config_type._module} vector database:\")\n    for name in dir(module):\n        if not name.startswith(\"_\"):\n            try:\n                inspect.signature(getattr(module, name))\n                print(f\"- {name} (available) \u2705\")\n            except NotImplementedError:\n                print(f\"- {name} (Not implemented) \u274c\")\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabaseConfig","title":"<code>modaic.databases.vector_database.VectorDatabaseConfig()</code>  <code>dataclass</code>","text":"<p>Base class for vector database configurations. Each subclass must implement the <code>_module</code> class variable.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase","title":"<code>modaic.databases.vector_database.InMemoryVectorDatabase(embedder: dspy.Embedder, metadata_schema: Type[BaseModel] = None, **kwargs)</code>","text":"<p>               Bases: <code>VectorDatabase</code></p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def __init__(\n    self, embedder: dspy.Embedder, metadata_schema: Type[BaseModel] = None, **kwargs\n):\n    from .integrations.milvus import MilvusVDBConfig\n\n    in_memory_config = MilvusVDBConfig()\n    super().__init__(in_memory_config, embedder, metadata_schema, **kwargs)\n    self.data_map = {}\n</code></pre>"}]}