{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Modaic Docs","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Install Modaic</p> <pre><code>uv install modaic\n</code></pre>"},{"location":"#modaic-principles","title":"Modaic Principles","text":"<p>In Modaic there are two types of context. <code>Molecular</code> and <code>Atomic</code>. Molecular context is</p>"},{"location":"#create-a-simple-rag-framework","title":"Create a Simple RAG Framework","text":"<p>Lets create a simple agent that can answer questions about the weather.</p> <pre><code>from modaic import PrecompiledAgent, PrecompiledConfig\n\nclass WeatherConfig(PrecompiledConfig):\n    agent_type = \"WeatherAgent\" # !! This is super important so you can load the agent later!!\n\nclass WeatherAgent(PrecompiledAgent):\n    config_class = WeatherConfig # !! This is super important to link the agent to the config!!\n    def __init__(self, config: WeatherConfig, **kwargs):\n        super().__init__(config, **kwargs)\n\n    def forward(self, query: str) -&gt; str:\n        return self.get_weather(query)\n\n    def get_weather(self, city: str) -&gt; str:\n        return f\"The weather in {city} is sunny.\"\n\nagent = WeatherAgent(PrecompiledConfig())\nagent.forward(\"What is the weather in Tokyo?\")\n</code></pre>"},{"location":"#defining-your-own-context","title":"Defining your own context","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"guides/context_engineering/","title":"Context Engineering with Modaic","text":"<p>Modaic comes with a powerful context engineering toolkit that is designed to be extremely flexible while still being portable and easy to use. In our SDK you have a range of context types to choose from and you can also easily define your own context class with custom behavior. From simple context classes like text and images to more complex context classes like tables, code bases, and user profiles.</p>"},{"location":"guides/context_engineering/#molecular-and-atomic-context","title":"Molecular and Atomic Context","text":"<p>Wait... why are we talking about chemistry? Good question. In Modaic we split context into two parts. Molecular and Atomic. <code>Atomic</code> context, as the name suggests, is atomic. It cannot be broken down into further parts. Some examples include text, a single image, or a single website element. <code>Molecular</code> context is a context which can be chunked into smaller parts of either <code>Atomic</code> or <code>Molecular</code> context. Like a markdown doc, a pdf, or a website. When you create a custom context class you will extend from one of these two base classes.</p>"},{"location":"guides/context_engineering/#serializedcontext","title":"SerializedContext","text":"<p>The <code>SerializedContext</code> class helps define how our context objects will be serialized and deserialized when they are stored in vector and graph databases. Every context class must define a class attribute called <code>serialized_context_class</code> which points to its to a child class of <code>SerializedContext</code> and defines what fields from your context class will be serialized and how. <code>SerializedContext</code> under the hood is a <code>pydantic.BaseModel</code> so you can use all the features of pydantic to define your serialized context class.</p>"},{"location":"guides/context_engineering/#source-tracking","title":"Source Tracking","text":"<p>All context classes automatically track their source. Throughout your entire framework. The <code>Source</code> class which is a <code>pydantic.BaseModel</code> that contains the following fields:</p> <ul> <li><code>origin: Optional[str]</code>: The filename, url, or hostname the context originates from</li> <li><code>type: Optional[SourceType]</code>: The type of origin can be one of the following:</li> <li><code>SourceType.LOCAL_PATH</code>: The context is a local file path</li> <li><code>SourceType.URL</code>: The context is a url</li> <li><code>SourceType.SQL_DB</code>: The context is a SQL database</li> <li><code>metadata: dict</code>: Source metadata that can be used to identify the context in the origin. For example, a chunk id, row id, or table id.</li> <li><code>parent: Optional[Context]</code>: A special property that is not serialized but contains a weakref to the context's parent context. </li> </ul> <p>Warning</p> <p><code>parent</code> is a weakref to the parent context object. When the parent context goes out of scope, <code>source.parent</code> will be <code>None</code>. Also, <code>parent</code> is never serialized.</p>"},{"location":"guides/context_engineering/#methods","title":"Methods","text":""},{"location":"guides/context_engineering/#predefined-methods","title":"Predefined Methods","text":"<p>All <code>Context</code> classes come with 2 main methods: <pre><code>def serialize(self) -&gt; SerializedContext:\n    \"\"\"Serialize the context into a `SerializedContext` object.\"\"\"\n</code></pre> <pre><code>@classmethod\ndef deserialize(cls, serialized: SerializedContext | dict, **kwargs) -&gt; Context:\n    \"\"\"Deserialize the context from a `SerializedContext` object. Can use kwargs to pass in additional fields to the Context constructor. \n    For example, fields that were not serialized but are needed to initialize the context. Or fields that you would like to override from the serialized context.\"\"\"\n</code></pre></p> <p>Additionally, the context classes that extend from <code>Molecular</code> have a <code>chunk</code> method that can be used to chunk the context into smaller parts. It has the following signature:</p> <pre><code>def chunk(self, chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs) -&gt; bool:\n    \"\"\"\n     Chunks a Molecular context into smaller parts of either `Atomic` or `Molecular` context. Chunks will be stored in the `.chunks` attribute.\n     Args:\n     - chunk_fn: A function that takes a context and returns a list of context objects.\n     - set_source: Whether to automatically set the source of the chunked context objects based on the parent context.\n     - **kwargs: Additional keyword arguments to pass to the chunk function.\n    \"\"\"\n</code></pre> <p>Tip</p> <p>All the above methods are automatically implemented for you when you extend from <code>Atomic</code> or <code>Molecular</code>. No need to override them. Unless you want to of course :wink:  </p>"},{"location":"guides/context_engineering/#abstract-methods","title":"Abstract Methods","text":"<p>The below methods are abstract methods that you must override when you extend from <code>Atomic</code> or <code>Molecular</code>.</p> <p><pre><code>    @abstractmethod\n    def embedme(self) -&gt; str | PIL.Image.Image:\n        \"\"\"\n        Abstract method defined by all subclasses of `Context` to define embedding behavior for embedding models.\n        Returns:\n            The string or image that should be used to embed the context.\n        \"\"\"\n</code></pre> <pre><code>    @abstractmethod\n    def readme(self) -&gt; str:\n        \"\"\"\n        Abstract method defined by all subclasses of `Context` to define readme behavior for LLMs.\n        Returns:\n            The readme string that should be read by LLMs.\n        \"\"\"\n</code></pre></p>"},{"location":"guides/context_engineering/#storage","title":"Storage","text":""},{"location":"guides/custom_context/","title":"Create A Custom Context Class","text":"<p>In this guide we will show you how to create your own context class. The context engineering toolkit in Modaic is extremely powerful and flexible. To learn more about how it works, check out the context engineering guide. In this guide we will show you how to create a custom user profile and organization profile context class for a social networking agent.</p>"},{"location":"guides/custom_context/#the-userprofile-class","title":"The UserProfile class","text":"<p>First we will define the <code>UserProfile</code> class as well as its <code>SerializedUserProfile</code> class. <pre><code>from modaic.context import Atomic, Molecular, SerializedContext\nimport requests\nfrom PIL import Image\nfrom io import BytesIO\n\n# First we define UserProfile's SerializedContext class.\n# As you can see below, only name, age, email,and description will be serialized. profile_pic will be loaded during construction.\nclass SerializedUserProfile(SerializedContext):\n    name: str\n    age: int\n    description: str\n    email: str\n\nclass UserProfile(Atomic):\n    serialized_context_class = SerializedUserProfile # !!! Super important for serialization and deserialization.\n    def __init__(self, name: str, age: int, description: str, email: str, profile_pic: PIL.Image.Image, **kwargs):\n        # All attibutes that will be serialized must match fields of SerializedUserProfile\n        super().__init__(**kwargs) # !!! Important. Allows the parent class to initalize source and metadata.\n        self.name = name \n        self.age = age\n        self.description = description\n        self.email = email\n        self.profile_pic = self.get_profile_pic()\n\n    def get_profile_pic(self) -&gt; PIL.Image.Image:\n        \"\"\"\n        Abstract method that should be implemented by all subclasses of `Atomic` to define how the profile picture should be loaded.\n        Returns:\n            The profile picture as a PIL.Image.Image object.\n        \"\"\"\n        response = requests.get(self.source.origin)\n        return Image.open(BytesIO(response.content))\n\n    # Define the abstract method embedme\n    def embedme(self) -&gt; str:\n        return self.description\n\n    # Define the abstract method readme\n    def readme(self) -&gt; str:\n        return f\"\"\"\n        User Name: {self.name}\n        Age: {self.age}\n        Email: {self.email}\n        Description: {self.description}\n        \"\"\"\n</code></pre> So what did we do here?  1. We defined the <code>UserProfile</code> class that extends from the <code>Atomic</code> context type. It has the attributes <code>name</code>, <code>age</code>, <code>description</code>, <code>email</code>, and <code>profile_pic</code>. Profile pic is dynamically loaded from the backend. 2. We defined the <code>SerializedUserProfile</code> which determines serialization behavior for the <code>UserProfile</code> class. It expects the attributes <code>name</code>, <code>age</code>, <code>description</code>, and <code>email</code>. It will ignore the <code>profile_pic</code> attribute. 3. We implemented the <code>embedme</code> method which returns the <code>description</code> of the user. 4. We implemented the <code>readme</code> method which returns a string that represents the user profile.</p> <p>Let's see what this looks like in action!</p> <p><pre><code>from modaic.databases import VectorDatabase, MilvusVDBConfig\nfrom modaic.utils import Embedder\nfrom modaic.context import Source, SourceType\nimport dspy\n\nmilvus_config = MilvusVDBConfig.from_local(file_path=\"index.db\")\nvector_db = VectorDatabase(\n    config=milvus_config,\n    embedder=Embedder(model=\"openai/text-embedding-3-small\"),\n)\n\nuser_profile1 = UserProfile(\n    name=\"John Doe\",\n    age=30,\n    description=\"John Doe is a software engineer at Google. He also loves dogs.\",\n    email=\"john.doe@gmail.com\",\n    source=Source(origin=\"https://example.com/john_doe\", type=SourceType.URL),\n)\nuser_profile2 = UserProfile(\n    name=\"Jane Smith\",\n    age=25,\n    description=\"Jane Smith is a software engineer at Meta.\",\n    email=\"jane.smith@gmail.com\",\n    source=Source(origin=\"https://example.com/jane_smith\", type=SourceType.URL),\n)\nvector_db.create_collection(\"user_profiles\", payload_schema=SerializedUserProfile)\n\n# Add records to the vector database. The `add_records` method will automatically call the `.embedme()` function and pass the result into the Embedder to embed the context.\nvector_db.add_records(\n    \"user_profiles\",\n    [user_profile1, user_profile2],\n)\n\n# Now lets search for user profiles.\nmeta_employee = vector_db.search(\n    \"user_profiles\",\n    \"Someone who works at Meta\",\n    k=1,\n)\n# This should *hopefully* return Jane Smith.\n\n# Now lets have an give us a summary of the meta employee.\n\nsummarizer = dspy.Predict(\"user_profile -&gt; summary\")\nsummarizer.set_lm(dspy.LM(model=\"openai/gpt-4o-mini\"))\n\nsummary = summarizer(user_profile=meta_employee.readme())\n</code></pre> What happened here? 1. We created two user profiles and added them to the vector database. The vector database automatically used <code>description</code> to embed the context. Since that is what <code>embedme()</code> returns 2. We fetched the <code>meta_employee</code> context from the vector database, then summarized the profile by feeding in the result of the <code>readme</code> method to a dspy.Predict module. (just a simple LLM call)</p>"},{"location":"guides/custom_context/#alternate-implementation","title":"Alternate Implementation","text":"<p>What if instead we wanted to embed users based on what they look like? All we would have to do is change the <code>embedme</code> method to return the profile picture.</p> <pre><code>def embedme(self) -&gt; PIL.Image.Image:\n    return self.profile_pic\n</code></pre>"},{"location":"guides/custom_context/#the-organizationprofile-class","title":"The OrganizationProfile class","text":"<p>Now that we have a <code>UserProfile</code> class, we can create an <code>OrganizationProfile</code> class. That is composed of multiple <code>UserProfile</code>s. Since UserProfile can be chunked, it is a good idea to make it extend the <code>Molecular</code> context type.</p> <pre><code>from modaic.context import Molecular\nimport requests\n\nclass SerializedOrganizationProfile(SerializedContext):\n    name: str\n    website_url: str\n\nclass OrganizationProfile(Molecular):\n    def __init__(self, name: str, website_url: str, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.website_url = website_url\n    # We won't define a proper embedme since we aren't going to be embedding organization profiles.\n    def embedme(self) -&gt; str: \n        pass\n\n    def readme(self) -&gt; str:\n        return f\"\"\"\n        Organization Name: {self.name}\n        Description: {self.description}\n        \"\"\"\n\n    # We will also define a method that fetches an organization profile from a url.\n    @staticmethod\n    def from_url(url: str) -&gt; OrganizationProfile:\n        org = requests.get(url).json().data\n        return OrganizationProfile(**org)\n\ndef chunk_by_user(org_profile: OrganizationProfile) -&gt; list[UserProfile]:\n    users = requests.get(f'{org_profile.source.origin}/users').json().data\n    return [UserProfile(**user) for user in users]\n\n# Now lets create an organization profile.\norg_profile1 = OrganizationProfile(\n    name=\"Google\",\n    description=\"Google is a search engine company.\",\n    source=Source(origin=\"https://api.example.com/google\", type=SourceType.URL),\n)\norg_profile2 = OrganizationProfile(\n    name=\"Meta\",\n    description=\"Meta is a social networking company.\",\n    source=Source(origin=\"https://api.example.com/meta\", type=SourceType.URL),\n)\n\nvector_db.create_collection(\"user_profiles\", payload_schema=SerializedOrganizationProfile)\n\norg_profile1.chunk(chunk_fn=chunk_by_user)\norg_profile2.chunk(chunk_fn=chunk_by_user)\n\nvector_db.add_records(\n    \"user_profiles\",\n    org_profile1.chunks + org_profile2.chunks,\n)\n\n# Now lets search for user profiles.\ndog_lover = vector_db.search(\n    \"user_profiles\",\n    \"Someone who loves dogs\",\n    k=1,\n)\n\n# We can use the source attribute to get the organization this profile belongs to.\norg_url = dog_lover.source.origin\norg_profile = OrganizationProfile.from_url(org_url)\n</code></pre>"},{"location":"guides/custom_context/#advanced-usage-grabbing-values-at-serialization-time","title":"Advanced Usage: Grabbing values at serialization time","text":"<p>Lets say we want to add a last accessed timestamp to out user profile for filtering in the vector database. <pre><code>import datetime\n\nclass SerializedUserProfile(SerializedContext):\n    name: str\n    age: int\n    description: str\n    email: str\n    last_accessed: str\n\nclass UserProfile(Molecular):\n    def __init__(self, name: str, age: int, description: str, email: str, last_accessed: datetime.datetime, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.age = age\n        self.description = description\n        self.email = email\n        self.last_accessed = datetime.datetime.now().isoformat()\n</code></pre> We have a problem! <code>last_accessed</code> will refer to the time of constructution, not of serialization. The solution? We can actually add the output of functions to <code>SerializedUserProfile</code> as long as they are can be called with no arguments. <pre><code>class SerializedUserProfile(SerializedContext):\n    name: str\n    age: int\n    description: str\n    email: str\n    last_accessed: str\n\nclass UserProfile(Molecular):\n    def __init__(self, name: str, age: int, description: str, email: str, last_accessed: datetime.datetime, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.age = age\n        self.description = description\n        self.email = email\n\n    def last_accessed(self) -&gt; str:\n        return datetime.datetime.now().isoformat()\n</code></pre></p> <p>the <code>serialize</code> funtion will automatically look for a function names <code>last_accessed</code> and call it to get the value of <code>last_accessed</code> during serialization.</p>"},{"location":"reference/precompiled_agent/","title":"PrecompiledAgent","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent","title":"<code>modaic.precompiled_agent.PrecompiledAgent(config: PrecompiledConfig, **kwargs)</code>","text":"<p>Bases: <code>dspy.Module</code></p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def __init__(self, config: PrecompiledConfig, **kwargs):\n    self.config = config\n    assert config.agent_type == self.__class__.__name__, (\n        f\"Config agent_type must match agent class name. Expected {self.__class__.__name__}, got {config.agent_type}\"\n    )\n    assert isinstance(config, self.config_class), (\n        f\"Config must be an instance of {self.config_class.__name__}\"\n    )\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent-functions","title":"Functions","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.forward","title":"<code>forward(**kwargs) -&gt; str</code>","text":"<p>Forward pass for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Forward pass result.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def forward(self, **kwargs) -&gt; str:\n    \"\"\"\n    Forward pass for the agent.\n\n    Args:\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Forward pass result.\n    \"\"\"\n    raise NotImplementedError(\n        \"Forward pass for PrecompiledAgent is not implemented. You must implement a forward method in your subclass.\"\n    )\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the agent and the config to the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the agent and config to. Must be a local path.</p> required Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def save_precompiled(self, path: str) -&gt; None:\n    \"\"\"\n    Saves the agent and the config to the given path.\n\n    Args:\n        path: The path to save the agent and config to. Must be a local path.\n    \"\"\"\n    path = pathlib.Path(path)\n    path.mkdir(parents=True, exist_ok=True)\n    self.config.save_precompiled(path)\n    self.save(path / \"agent.json\")\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.from_precompiled","title":"<code>from_precompiled(path: str, **kwargs) -&gt; PrecompiledAgent</code>  <code>classmethod</code>","text":"<p>Loads the agent and the config from the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the agent and config from. Can be a local path or a path on Modaic Hub.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PrecompiledAgent</code> <p>An instance of the PrecompiledAgent class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_precompiled(cls, path: str, **kwargs) -&gt; \"PrecompiledAgent\":\n    \"\"\"\n    Loads the agent and the config from the given path.\n\n    Args:\n        path: The path to load the agent and config from. Can be a local path or a path on Modaic Hub.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        An instance of the PrecompiledAgent class.\n    \"\"\"\n    assert cls.config_class is not None, (\n        f\"Config class must be set for {cls.__name__}. \\nHint: PrecompiledAgent.from_precompiled(path) will not work. You must use a subclass of PrecompiledAgent.\"\n    )\n    path = pathlib.Path(path)\n    config = cls.config_class.from_precompiled(path)\n    agent = cls(config, **kwargs)\n    return agent\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.push_to_hub","title":"<code>push_to_hub(repo_id: str) -&gt; None</code>","text":"<p>Pushes the agent and the config to the given repo_id.</p> <p>Parameters:</p> Name Type Description Default <code>repo_id</code> <code>str</code> <p>The path on Modaic hub to save the agent and config to.</p> required Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def push_to_hub(self, repo_id: str) -&gt; None:\n    \"\"\"\n    Pushes the agent and the config to the given repo_id.\n\n    Args:\n        repo_id: The path on Modaic hub to save the agent and config to.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig","title":"<code>modaic.precompiled_agent.PrecompiledConfig(**kwargs)</code>","text":"Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def __init__(self, **kwargs):\n    for k, v in kwargs.items():\n        try:\n            setattr(self, k, v)\n        except AttributeError as e:\n            print(\n                f\"Warning: {k} is not a valid attribute for {self.__class__.__name__}\"\n            )\n            raise e\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig-functions","title":"Functions","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the config to a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the config to.</p> required Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>def save_precompiled(self, path: str) -&gt; None:\n    \"\"\"\n    Saves the config to a config.json file in the given path.\n\n    Args:\n        path: The path to save the config to.\n    \"\"\"\n    print(self.__dict__)\n    print(self.agent_type)\n    path = pathlib.Path(path)\n    path.mkdir(parents=True, exist_ok=True)\n    with open(path / \"config.json\", \"w\") as f:\n        json.dump(self.__dict__, f, indent=2)\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_precompiled","title":"<code>from_precompiled(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_precompiled(cls, path: str) -&gt; \"PrecompiledConfig\":\n    \"\"\"\n    Loads the config from a config.json file in the given path.\n\n    Args:\n        path: The path to load the config from.\n\n    Returns:\n        An instance of the PrecompiledConfig class.\n    \"\"\"\n    path = pathlib.Path(path) / \"config.json\"\n    with open(path, \"r\") as f:\n        config_dict = json.load(f)\n        return cls(**config_dict)\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_dict","title":"<code>from_dict(dict: Dict) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <code>Dict</code> <p>A dictionary containing the config.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_dict(cls, dict: Dict) -&gt; \"PrecompiledConfig\":\n    \"\"\"\n    Loads the config from a dictionary.\n\n    Args:\n        dict: A dictionary containing the config.\n\n    Returns:\n        An instance of the PrecompiledConfig class.\n    \"\"\"\n    instance = cls(**dict)\n    return instance\n</code></pre>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_json","title":"<code>from_json(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p> Source code in <code>src/modaic/precompiled_agent.py</code> <pre><code>@classmethod\ndef from_json(cls, path: str) -&gt; \"PrecompiledConfig\":\n    \"\"\"\n    Loads the config from a json file.\n\n    Args:\n        path: The path to load the config from.\n\n    Returns:\n        An instance of the PrecompiledConfig class.\n    \"\"\"\n    with open(path, \"r\") as f:\n        return cls.from_dict(json.load(f))\n</code></pre>"},{"location":"reference/context/context/","title":"Context","text":""},{"location":"reference/context/context/#modaic.context.Context","title":"<code>modaic.context.Context(source: Optional[Source] = None, metadata: dict = {})</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/modaic/context/base.py</code> <pre><code>def __init__(self, source: Optional[Source] = None, metadata: dict = {}):\n    self.source = source\n    self.metadata = metadata\n</code></pre>"},{"location":"reference/context/context/#modaic.context.Context-functions","title":"Functions","text":""},{"location":"reference/context/context/#modaic.context.Context.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context. Returns:     The string or image that should be used to embed the context.</p> Source code in <code>src/modaic/context/base.py</code> <pre><code>@abstractmethod\ndef embedme(self) -&gt; str | PIL.Image.Image:\n    \"\"\"\n    Abstract method defined by all subclasses of `Context` to define how embedding modeles should embed the context.\n    Returns:\n        The string or image that should be used to embed the context.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/context/context/#modaic.context.Context.readme","title":"<code>readme() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how LLMs should read the context. Returns:     The string that should be read by LLMs.</p> Source code in <code>src/modaic/context/base.py</code> <pre><code>@abstractmethod\ndef readme(self) -&gt; str:\n    \"\"\"\n    Abstract method defined by all subclasses of `Context` to define how LLMs should read the context.\n    Returns:\n        The string that should be read by LLMs.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/context/serialized_context/","title":"SerializedContext","text":""},{"location":"reference/context/serialized_context/#modaic.context.SerializedContext","title":"<code>modaic.context.SerializedContext</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class used to define the schema of a context object when they are serialized. Args:     context_class: ClassVar[str] - The class of the context object that this serialized context is for.     id: str - The id of the serialized context.     source: Source - The source of the context object.     metadata: dict - The metadata of the context object. Example:     In this example, SerializedCaptionedImage stores the caption and the caption embedding while CaptionedImage is the Context class that is used to store the context object.     Note that the image is loaded dynamically in the CaptionedImage class and is not serialized to SerializedCaptionedImage.     <pre><code>from modaic.context import SerializedContext\nfrom modaic.types import String, Vector, Float16Vector\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float16Vector[384]\n    image_path: String[100]\n\nclass CaptionedImage(Atomic):\n    serialized_context_class = SerializedCaptionedImage\n\n    def __init__(self, image_path: str, caption: str, caption_embedding: np.ndarray, **kwargs):\n        super().__init__(**kwargs)\n        self.caption = caption\n        self.caption_embedding = caption_embedding\n        self.image_path = image_path\n        self.image = PIL.Image.open(image_path)\n\n    def embedme(self) -&gt; PIL.Image.Image:\n        return self.image\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types","title":"<code>modaic.types</code>","text":""},{"location":"reference/context/serialized_context/#modaic.types-classes","title":"Classes","text":""},{"location":"reference/context/serialized_context/#modaic.types.Vector","title":"<code>Vector</code>","text":"<p>               Bases: <code>List</code></p> <p>float vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Vector[dim] Args:     dim (int): Required. The dimension of the vector. Example:     The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption.     <pre><code>from modaic.types import Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.Float16Vector","title":"<code>Float16Vector</code>","text":"<p>               Bases: <code>Vector</code></p> <p>float16 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Float16Vector[dim] Args:     dim (int): Required. The dimension of the vector. Example:     <pre><code>from modaic.types import Float16Vector\nfrom modaic.context import SerializedContext\n\n# Case where we want to store a secondary embedding for the caption of an image.\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float16Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.Float32Vector","title":"<code>Float32Vector</code>","text":"<p>               Bases: <code>Vector</code></p> <p>float32 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Float32Vector[dim] Args:     dim (int): Required. The dimension of the vector. Example:     The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption.     <pre><code>from modaic.types import Float32Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float32Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.Float64Vector","title":"<code>Float64Vector</code>","text":"<p>               Bases: <code>Vector</code></p> <p>float64 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Float64Vector[dim] Args:     dim (int): Required. The dimension of the vector. Example:     The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption.     <pre><code>from modaic.types import Float64Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float64Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.BFloat16Vector","title":"<code>BFloat16Vector</code>","text":"<p>               Bases: <code>Vector</code></p> <p>bfloat16 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with BFloat16Vector[dim] Args:     dim (int): Required. The dimension of the vector. Example:     The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption.     <pre><code>from modaic.types import BFloat16Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: BFloat16Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.BinaryVector","title":"<code>BinaryVector</code>","text":"<p>               Bases: <code>Vector</code></p> <p>binary vector field type for <code>SerializedContext</code> of the given dimension. Must be created with BinaryVector[dim] Args:     dim (int): Required. The dimension of the vector. Example:     The <code>SerializedContext</code> class for a <code>SenateBill</code> Context type that uses a binary vector to store the vote distribution.     <pre><code>from modaic.types import BinaryVector\nfrom modaic.context import SerializedContext\n\nclass SerializedSenateBill(SerializedContext):\n    bill_id: int\n    bill_title: String[10]\n    bill_description: String\n    vote_distribution: BinaryVector[100]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.Array","title":"<code>Array</code>","text":"<p>               Bases: <code>List</code></p> <p>Array field type for <code>SerializedContext</code>. Must be created with Array[dtype, max_size] Args:     dtype: Type (required) - The type of the elements in the array.     max_size: int (required) - The maximum size of the array. Example:     ```python     from modaic.types import Array</p>"},{"location":"reference/context/serialized_context/#modaic.types.String","title":"<code>String</code>","text":"<p>               Bases: <code>str</code></p> <p>String type that can be parameterized with max_length constraint.</p> <p>Can be used as: - String[50] for type annotations with max length validation - String(\"hello\") for creating string instances</p>"},{"location":"reference/context/table/","title":"Table","text":"<p>handler: python</p> <p>handler: python</p>"},{"location":"reference/context/table/#modaic.context.table.Table","title":"<code>modaic.context.table.Table(df: pd.DataFrame, name: str, prepare_for_sql: bool = True, **kwargs)</code>","text":"<p>               Bases: <code>Molecular</code></p> <p>A molecular context object that represents a table. Can be queried with SQL.</p> <p>Initializes a Table context object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to represent as a table.</p> required <code>name</code> <code>str</code> <p>The name of the table.</p> required <code>prepare_for_sql</code> <code>bool</code> <p>Whether to prepare the table for SQL queries.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Molecular context object.</p> <code>{}</code> Source code in <code>src/modaic/context/table.py</code> <pre><code>def __init__(\n    self, df: pd.DataFrame, name: str, prepare_for_sql: bool = True, **kwargs\n):\n    \"\"\"\n    Initializes a Table context object.\n\n    Args:\n        df: The dataframe to represent as a table.\n        name: The name of the table.\n        prepare_for_sql: Whether to prepare the table for SQL queries.\n        **kwargs: Additional keyword arguments to pass to the Molecular context object.\n    \"\"\"\n    super().__init__(**kwargs)\n    self._df = df\n    self.name = name\n\n    if prepare_for_sql:\n        self.sanitize_columns()\n        if not is_valid_table_name(name):\n            self.name = Table.sanitize_name(name)\n            warnings.warn(\n                f\"Table name {name} is not a valid SQL table name and has been sanitized to {self.name}. To keep the original name, initialize with `prepare_for_sql=False`\"\n            )\n    self._chunks = []\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table-functions","title":"Functions","text":""},{"location":"reference/context/table/#modaic.context.table.Table.get_col","title":"<code>get_col(col_name: str) -&gt; pd.Series</code>","text":"<p>Gets a single column from the table.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the column to get</p> required <p>Returns:</p> Type Description <code>Series</code> <p>The specified column as a pandas Series.</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def get_col(self, col_name: str) -&gt; pd.Series:\n    \"\"\"\n    Gets a single column from the table.\n\n    Args:\n        col_name: Name of the column to get\n\n    Returns:\n        The specified column as a pandas Series.\n    \"\"\"\n    return self._df[col_name]\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.get_schema_with_samples","title":"<code>get_schema_with_samples()</code>","text":"<p>Returns a dictionary of mapping column names to dictionaries containing the column type and sample values. Examples:</p> <p>df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]}) table = Table(df, name=\"table\") table.get_schema_with_samples() {\"Column1\": {\"type\": \"INT\", \"sample_values\": [1, 2, 3]}, \"Column2\": {\"type\": \"INT\", \"sample_values\": [4, 5, 6]}, \"Column3\": {\"type\": \"INT\", \"sample_values\": [7, 8, 9]}}</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def get_schema_with_samples(self):  # TODO; Rename and add docstring\n    \"\"\"\n    Returns a dictionary of mapping column names to dictionaries containing the column type and sample values.\n    Examples:\n    &gt;&gt;&gt; df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]})\n    &gt;&gt;&gt; table = Table(df, name=\"table\")\n    &gt;&gt;&gt; table.get_schema_with_samples()\n    {\"Column1\": {\"type\": \"INT\", \"sample_values\": [1, 2, 3]}, \"Column2\": {\"type\": \"INT\", \"sample_values\": [4, 5, 6]}, \"Column3\": {\"type\": \"INT\", \"sample_values\": [7, 8, 9]}}\n    \"\"\"\n    column_dict = {}\n    for col in self._df.columns:\n        if isinstance(self._df[col], pd.DataFrame):\n            print(f\"Column {col} is a DataFrame, skipping...\")\n            raise ValueError(\n                f\"Column {col} is a DataFrame, which is not supported.\"\n            )\n        column_dict[col] = {\n            \"type\": pandas_to_mysql_dtype(self._df[col].dtype),\n            \"sample_values\": self.get_sample_values(col),\n        }\n\n    return column_dict\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.query","title":"<code>query(query: str)</code>","text":"<p>Queries the table. All queries run should refer to the table as <code>this</code> or <code>This</code></p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def query(self, query: str):  # TODO: add example\n    \"\"\"\n    Queries the table. All queries run should refer to the table as `this` or `This`\n    \"\"\"\n    return duckdb.query_df(self._df, \"this\", query).to_df()\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.markdown","title":"<code>markdown() -&gt; str</code>","text":"<p>Converts the table to markdown format. Returns a markdown representation of the table with the table name as header.</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def markdown(self) -&gt; str:  # TODO: add example\n    \"\"\"\n    Converts the table to markdown format.\n    Returns a markdown representation of the table with the table name as header.\n    \"\"\"\n    content = \"\"\n    content += f\"Table name: {self.name}\\n\"\n\n    # Add header row\n    columns = [str(col) for col in self._df.columns]\n    content += \"| \" + \" | \".join(columns) + \" |\\n\"\n\n    # Add header separator\n    content += \"| \" + \" | \".join([\"---\"] * len(columns)) + \" |\\n\"\n\n    # Add data rows\n    for _, row in self._df.iterrows():\n        row_values = []\n        for value in row:\n            if pd.isna(value) or value is None:\n                row_values.append(\"\")\n            else:\n                row_values.append(str(value))\n        content += \"| \" + \" | \".join(row_values) + \" |\\n\"\n\n    return content\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.readme","title":"<code>readme()</code>","text":"<pre><code>    readme method for table. Returns a markdown representation of the table.\n    Examples:\n    &gt;&gt;&gt; df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]})\n    &gt;&gt;&gt; table = Table(df, name=\"table\")\n    &gt;&gt;&gt; table.readme()\n    \"Table name: table\n</code></pre> <p>\"         \" | Column1 | Column2 | Column3 |  \"         \" | --- | --- | --- |  \"         \" | 1 | 2 | 3 |  \"         \" | 4 | 5 | 6 |  \"         \" | 7 | 8 | 9 |  \"</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def readme(self):\n    \"\"\"\n    readme method for table. Returns a markdown representation of the table.\n    Examples:\n    &gt;&gt;&gt; df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]})\n    &gt;&gt;&gt; table = Table(df, name=\"table\")\n    &gt;&gt;&gt; table.readme()\n    \"Table name: table\\n\"\n    \" | Column1 | Column2 | Column3 | \\n\"\n    \" | --- | --- | --- | \\n\"\n    \" | 1 | 2 | 3 | \\n\"\n    \" | 4 | 5 | 6 | \\n\"\n    \" | 7 | 8 | 9 | \\n\"\n    \"\"\"\n    return self.markdown()\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.embedme","title":"<code>embedme()</code>","text":"<p>embedme method for table. Returns a markdown representation of the table.</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def embedme(self):\n    \"\"\"\n    embedme method for table. Returns a markdown representation of the table.\n    \"\"\"\n    return self.markdown()\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable","title":"<code>modaic.context.table.MultiTabbedTable(tables: dict[str, Table], **kwargs)</code>","text":"<p>               Bases: <code>Molecular</code></p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def __init__(self, tables: dict[str, Table], **kwargs):\n    super().__init__(**kwargs)\n    self.tables = tables\n    self.sql_db = None\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable-functions","title":"Functions","text":""},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.init_sql","title":"<code>init_sql()</code>","text":"<p>Initilizes and in memory sql database for querying</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def init_sql(self):\n    \"\"\"\n    Initilizes and in memory sql database for querying\n    \"\"\"\n    self.sql_db = duckdb.connect(database=\":memory:\")\n    for table_name, table in self.tables.items():\n        self.sql_db.register(table_name, table.df)\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.close_sql","title":"<code>close_sql()</code>","text":"<p>Closes the in memory sql database</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def close_sql(self):\n    \"\"\"\n    Closes the in memory sql database\n    \"\"\"\n    self.sql_db.close()\n    self.sql_db = None\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.query","title":"<code>query(query: str)</code>","text":"<p>Queries the in memory sql database</p> Source code in <code>src/modaic/context/table.py</code> <pre><code>def query(self, query: str):\n    \"\"\"\n    Queries the in memory sql database\n    \"\"\"\n    if self.sql_db is None:\n        raise ValueError(\n            \"Attempted to run query on MultiTabbedTable without initializing the SQL database. Use with `with MultiTabbedTable.sql():` or `MultiTabbedTable.init_sql()`\"\n        )\n    try:\n        df = self.sql_db.execute(query).fetchdf()\n        return Table(\n            df=df, name=\"query_result\", source=Source(self, SourceType.OBJECT)\n        )\n    except Exception as e:\n        raise ValueError(f\"Error querying SQL database: {e}\")\n</code></pre>"},{"location":"reference/context/text/","title":"Text","text":"<p>handler: python</p> <p>handler: python</p>"},{"location":"reference/context/text/#modaic.context.text.Text","title":"<code>modaic.context.text.Text(text: str, *args, **kwargs)</code>","text":"<p>               Bases: <code>Atomic</code></p> Source code in <code>src/modaic/context/text.py</code> <pre><code>def __init__(self, text: str, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.text = text\n</code></pre>"},{"location":"reference/context/text/#modaic.context.text.LongText","title":"<code>modaic.context.text.LongText(text: str, *args, **kwargs)</code>","text":"<p>               Bases: <code>Molecular</code></p> Source code in <code>src/modaic/context/text.py</code> <pre><code>def __init__(self, text: str, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.text = text\n    self.chunks = []\n</code></pre>"},{"location":"reference/context/text/#modaic.context.text.LongText-functions","title":"Functions","text":""},{"location":"reference/context/text/#modaic.context.text.LongText.chunk_text","title":"<code>chunk_text(chunk_fn: Callable[[str], List[str | tuple[str, dict]]]) -&gt; List[Text]</code>","text":"<p>Chunk the text into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>Callable[[str], List[str | tuple[str, dict]]]</code> <p>A function that takes in a string and returns a list of strings or string-metadata pairs.</p> required <p>Returns:</p> Type Description <code>List[Text]</code> <p>A list of Context objects.</p> Source code in <code>src/modaic/context/text.py</code> <pre><code>def chunk_text(\n    self, chunk_fn: Callable[[str], List[str | tuple[str, dict]]]\n) -&gt; List[Text]:\n    \"\"\"\n    Chunk the text into smaller Context objects.\n\n    Args:\n        chunk_fn: A function that takes in a string and returns a list of strings or string-metadata pairs.\n\n    Returns:\n        A list of Context objects.\n    \"\"\"\n\n    # def context_chunk_fn(text: LongText) -&gt; List[Text]:\n    #     return [Text(text=text, source=self.source)]\n\n    def context_chunk_fn(long_text: LongText) -&gt; List[Text]:\n        return [Text(text=t) for t in chunk_fn(long_text.text)]\n\n    self.chunk_with(context_chunk_fn)\n</code></pre>"},{"location":"reference/databases/sql_database/","title":"SQL Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase","title":"<code>modaic.databases.sql_database.SQLDatabase(config: SQLDatabaseConfig | str, engine_kwargs: dict = {}, session_kwargs: dict = {})</code>","text":"Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def __init__(\n    self,\n    config: SQLDatabaseConfig | str,\n    engine_kwargs: dict = {},  # TODO: This may not be a smart idea, may want to enforce specific kwargs\n    session_kwargs: dict = {},  # TODO: This may not be a smart idea\n):\n    self.url = config.url if isinstance(config, SQLDatabaseConfig) else config\n    self.engine = create_engine(self.url, **engine_kwargs)\n    self.metadata = MetaData()\n    self.session = sessionmaker(bind=self.engine, **session_kwargs)\n    self.inspector = inspect(self.engine)\n    self.preparer = IdentifierPreparer(sqlite.dialect())\n\n    # Create metadata table to store table metadata\n    self.metadata_table = SQLTable(\n        \"metadata\",\n        self.metadata,\n        Column(\"table_name\", String(255), primary_key=True),\n        Column(\"metadata_json\", Text),\n    )\n    self.metadata.create_all(self.engine)\n    self.connection = None\n    self._in_transaction = False\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase-functions","title":"Functions","text":""},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.drop_table","title":"<code>drop_table(name: str, must_exist: bool = False)</code>","text":"<p>Drop a table from the database and remove its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to drop</p> required Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def drop_table(self, name: str, must_exist: bool = False):\n    \"\"\"\n    Drop a table from the database and remove its metadata.\n\n    Args:\n        name: The name of the table to drop\n    \"\"\"\n    if_exists = \"IF EXISTS\" if not must_exist else \"\"\n    safe_name = self.preparer.quote(name)\n    with self.connect() as connection:\n        command = text(f\"DROP TABLE {if_exists} {safe_name}\")\n        connection.execute(command)\n        # Also remove metadata for this table\n        connection.execute(\n            self.metadata_table.delete().where(\n                self.metadata_table.c.table_name == name\n            )\n        )\n        if self._should_commit():\n            connection.commit()\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.list_tables","title":"<code>list_tables()</code>","text":"<p>List all tables currently in the database.</p> <p>Returns:</p> Type Description <p>List of table names in the database.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def list_tables(self):\n    \"\"\"\n    List all tables currently in the database.\n\n    Returns:\n        List of table names in the database.\n    \"\"\"\n    # Refresh the inspector to ensure we get current table list\n    self.inspector = inspect(self.engine)\n    return self.inspector.get_table_names()\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_schema","title":"<code>get_table_schema(name: str)</code>","text":"<p>Return column schema for a given table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get schema for</p> required <p>Returns:</p> Type Description <p>Column schema information for the table.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def get_table_schema(self, name: str):\n    \"\"\"\n    Return column schema for a given table.\n\n    Args:\n        name: The name of the table to get schema for\n\n    Returns:\n        Column schema information for the table.\n    \"\"\"\n    return self.inspector.get_columns(name)\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_metadata","title":"<code>get_table_metadata(name: str) -&gt; dict</code>","text":"<p>Get metadata for a specific table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get metadata for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the table's metadata, or empty dict if not found.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def get_table_metadata(self, name: str) -&gt; dict:\n    \"\"\"\n    Get metadata for a specific table.\n\n    Args:\n        name: The name of the table to get metadata for\n\n    Returns:\n        Dictionary containing the table's metadata, or empty dict if not found.\n    \"\"\"\n    with self.connect() as connection:\n        result = connection.execute(\n            self.metadata_table.select().where(\n                self.metadata_table.c.table_name == name\n            )\n        ).fetchone()\n\n    if result:\n        return json.loads(result.metadata_json)\n    return {}\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.from_dir","title":"<code>from_dir(dir_path: str, config: SQLDatabaseConfig)</code>  <code>classmethod</code>","text":"<p>Initializes a new SQLDatabase from a directory of files.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>Path to the directory containing files to load</p> required <code>config</code> <code>SQLDatabaseConfig</code> <p>SQL database configuration</p> required <p>Returns:</p> Type Description <p>New SQLDatabase instance loaded with data from the directory.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>@classmethod\ndef from_dir(cls, dir_path: str, config: SQLDatabaseConfig):\n    # TODO: support batch inserting and parallel processing\n    \"\"\"\n    Initializes a new SQLDatabase from a directory of files.\n\n    Args:\n        dir_path: Path to the directory containing files to load\n        config: SQL database configuration\n\n    Returns:\n        New SQLDatabase instance loaded with data from the directory.\n    \"\"\"\n    # TODO: make sure the loaded sql database is empty if not raise error and tell user to use __init__ for an already existing database\n    instance = cls(config)\n    if not os.path.exists(dir_path):\n        raise FileNotFoundError(f\"File not found: {dir_path}\")\n    for file_name in tqdm(\n        os.listdir(dir_path), desc=\"Uploading files to SQL database\"\n    ):\n        full_path = os.path.join(dir_path, file_name)\n        if file_name.endswith(\".xlsx\") or file_name.endswith(\".xls\"):\n            table = Table.from_excel(full_path)\n            instance.add_table(table, if_exists=\"fail\")\n        elif file_name.endswith(\".csv\"):\n            table = Table.from_csv(full_path)\n            instance.add_table(table, if_exists=\"fail\")\n    return instance\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.connect","title":"<code>connect()</code>","text":"<p>Context manager for database connections. Reuses existing connection if available, otherwise creates a temporary one.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>@contextmanager\ndef connect(self):\n    \"\"\"\n    Context manager for database connections.\n    Reuses existing connection if available, otherwise creates a temporary one.\n    \"\"\"\n    connection_existed = self.connection is not None\n    if not connection_existed:\n        self.connection = self.engine.connect()\n\n    try:\n        yield self.connection\n    finally:\n        # Only close if we created the connection for this operation\n        if not connection_existed:\n            self.close()\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.open_persistent_connection","title":"<code>open_persistent_connection()</code>","text":"<p>Opens a persistent connection that will be reused across operations. Call close() to close the persistent connection.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def open_persistent_connection(self):\n    \"\"\"\n    Opens a persistent connection that will be reused across operations.\n    Call close() to close the persistent connection.\n    \"\"\"\n    if self.connection is None:\n        self.connection = self.engine.connect()\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.close","title":"<code>close()</code>","text":"<p>Closes the current connection if one exists.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes the current connection if one exists.\n    \"\"\"\n    if self.connection:\n        self.connection.close()\n        self.connection = None\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.begin","title":"<code>begin()</code>","text":"<p>Context manager for database transactions using existing connection. Requires an active connection. Commits on success, rolls back on exception.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no active connection exists</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>@contextmanager\ndef begin(self):\n    \"\"\"\n    Context manager for database transactions using existing connection.\n    Requires an active connection. Commits on success, rolls back on exception.\n\n    Raises:\n        RuntimeError: If no active connection exists\n    \"\"\"\n    if self.connection is None:\n        raise RuntimeError(\n            \"No active connection. Use connect_and_begin() or open a connection first.\"\n        )\n\n    transaction = self.connection.begin()\n    old_in_transaction = self._in_transaction\n    self._in_transaction = True\n\n    try:\n        yield self.connection\n        transaction.commit()\n    except Exception:\n        transaction.rollback()\n        raise\n    finally:\n        self._in_transaction = old_in_transaction\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.connect_and_begin","title":"<code>connect_and_begin()</code>","text":"<p>Context manager that establishes a connection and starts a transaction. Reuses existing connection if available, otherwise creates a temporary one. Commits on success, rolls back on exception.</p> Source code in <code>src/modaic/databases/sql_database.py</code> <pre><code>@contextmanager\ndef connect_and_begin(self):\n    \"\"\"\n    Context manager that establishes a connection and starts a transaction.\n    Reuses existing connection if available, otherwise creates a temporary one.\n    Commits on success, rolls back on exception.\n    \"\"\"\n    connection_existed = self.connection is not None\n    if not connection_existed:\n        self.connection = self.engine.connect()\n\n    transaction = self.connection.begin()\n    old_in_transaction = self._in_transaction\n    self._in_transaction = True\n\n    try:\n        yield self.connection\n        transaction.commit()\n    except Exception:\n        transaction.rollback()\n        raise\n    finally:\n        self._in_transaction = old_in_transaction\n        # Only close if we created the connection for this operation\n        if not connection_existed:\n            self.close()\n</code></pre>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLServerConfig","title":"<code>modaic.databases.sql_database.SQLServerConfig(user: str, password: str, host: str, database: str, port: Optional[str] = None, dialect: str = 'mysql', driver: Optional[str] = None, query_params: Optional[dict] = None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SQLDatabaseConfig</code></p> <p>Configuration for a SQL served over a port or remote connection. (MySQL, PostgreSQL, etc.)</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The username to connect to the database.</p> required <code>password</code> <code>str</code> <p>The password to connect to the database.</p> required <code>host</code> <code>str</code> <p>The host of the database.</p> required <code>database</code> <code>str</code> <p>The name of the database.</p> required <code>port</code> <code>Optional[str]</code> <p>The port of the database.</p> <code>None</code>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLiteConfig","title":"<code>modaic.databases.sql_database.SQLiteConfig(db_path: Optional[str] = None, in_memory: bool = False, query_params: Optional[dict] = None)</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SQLDatabaseConfig</code></p> <p>Configuration for a SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Optional[str]</code> <p>Path to the SQLite database file.</p> <code>None</code> <code>in_memory</code> <code>bool</code> <p>Whether to create an in-memory SQLite database.</p> <code>False</code> <code>query_params</code> <code>Optional[dict]</code> <p>Query parameters to pass to the database.</p> <code>None</code>"},{"location":"reference/databases/vector_database/","title":"Vector Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase","title":"<code>modaic.databases.vector_database.VectorDatabase(config: VectorDatabaseConfig, embedder: Embedder, payload_schema: Type[BaseModel] = None, **kwargs)</code>","text":"<p>Initialize a vanilla vector database. This is a base class for all vector databases. If you need more functionality from a specific vector database, you should use a specific subclass.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>VectorDatabaseConfig</code> <p>The configuration for the vector database</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder to use for the vector database</p> required <code>payload_schema</code> <code>Type[BaseModel]</code> <p>The Pydantic schema for validating context metadata</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def __init__(\n    self,\n    config: VectorDatabaseConfig,\n    embedder: Embedder,\n    payload_schema: Type[BaseModel] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a vanilla vector database. This is a base class for all vector databases. If you need more functionality from a specific vector database, you should use a specific subclass.\n\n    Args:\n        config: The configuration for the vector database\n        embedder: The embedder to use for the vector database\n        payload_schema: The Pydantic schema for validating context metadata\n        **kwargs: Additional keyword arguments\n    \"\"\"\n    self.config = config\n    self.embedder = embedder\n    self.payload_schema = payload_schema\n\n    # CAVEAT: this loads a module from /integrations, which implements custom logic for a specific vector database provider.\n    # CAVEAT It should be noted that some functions will raise NotImplementedErrors if the provider does not support the functionality.\n    try:\n        self.module = importlib.import_module(config._module)\n    except ImportError as e:\n        raise ImportError(f\"\"\"Unable to use the {config._module}, integration. Please make sure to install the module as an extra dependency for modaic.\n                          You can install the module by running: pip install modaic[{config._module}]\n                          OriginalError: {e}\"\"\")\n    self.client = self.module._init(config)\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase-functions","title":"Functions","text":""},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.create_collection","title":"<code>create_collection(collection_name: str, payload_schema: Optional[Type[BaseModel]] = None, embedding_dim: Optional[int] = None, exists_behavior: Literal['fail', 'replace', 'append'] = 'replace')</code>","text":"<p>Create a collection in the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create</p> required <code>payload_schema</code> <code>Optional[Type[BaseModel]]</code> <p>The schema of the collection</p> <code>None</code> <code>exists_behavior</code> <code>Literal['fail', 'replace', 'append']</code> <p>The behavior when the collection already exists</p> <code>'replace'</code> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def create_collection(\n    self,\n    collection_name: str,\n    payload_schema: Optional[Type[BaseModel]] = None,\n    embedding_dim: Optional[int] = None,\n    exists_behavior: Literal[\"fail\", \"replace\", \"append\"] = \"replace\",\n):\n    \"\"\"\n    Create a collection in the vector database.\n\n    Args:\n        collection_name: The name of the collection to create\n        payload_schema: The schema of the collection\n        exists_behavior: The behavior when the collection already exists\n    \"\"\"\n    # Check if collection exists\n    collection_exists = self.module.has_collection(self.client, collection_name)\n\n    if collection_exists:\n        if exists_behavior == \"fail\":\n            raise ValueError(\n                f\"Collection '{collection_name}' already exists and exists_behavior is set to 'fail'\"\n            )\n        elif exists_behavior == \"replace\":\n            self.module.drop_collection(self.client, collection_name)\n        elif exists_behavior == \"append\":\n            # If appending, just return as collection already exists\n            return\n\n    embedding_dim = (\n        self.embedder.embedding_dim if embedding_dim is None else embedding_dim\n    )\n    payload_schema = (\n        self.payload_schema if payload_schema is None else payload_schema\n    )\n    # Create the collection\n    self.module.create_collection(\n        self.client, collection_name, payload_schema, embedding_dim\n    )\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.add_records","title":"<code>add_records(collection_name: str, records: Iterable[Context | Tuple[str, SerializedContext]], batch_size: Optional[int] = None)</code>","text":"<p>Add items to a collection in the vector database. Uses the Context's get_embed_context() method and the embedder to create embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to add records to</p> required <code>records</code> <code>Iterable[Context | Tuple[str, SerializedContext]]</code> <p>The records to add to the collection</p> required <code>batch_size</code> <code>Optional[int]</code> <p>Optional batch size for processing records</p> <code>None</code> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def add_records(\n    self,\n    collection_name: str,\n    records: Iterable[Context | Tuple[str, SerializedContext]],\n    batch_size: Optional[int] = None,\n):\n    \"\"\"\n    Add items to a collection in the vector database.\n    Uses the Context's get_embed_context() method and the embedder to create embeddings.\n\n    Args:\n        collection_name: The name of the collection to add records to\n        records: The records to add to the collection\n        batch_size: Optional batch size for processing records\n    \"\"\"\n    if not records:\n        return\n\n    # Extract embed contexts from all items\n    embedmes = []\n    serialized_contexts = []\n\n    for i, item in tqdm(\n        enumerate(records), desc=\"Adding records to vector database\"\n    ):\n        match item:\n            case Context() as context:\n                embedme = context.embedme()\n                embedmes.append(embedme)\n                serialized_contexts.append(context.serialize())\n            case (str() as embedme, SerializedContext() as serialized_context):\n                embedmes.append(embedme)\n                serialized_contexts.append(serialized_context)\n            case _:\n                raise ValueError(\n                    f\"Unsupported VectorDatabase record format: {item}\"\n                )\n\n        if batch_size is not None and i % batch_size == 0:\n            print(\"Adding chunk\")\n            self._embed_and_add_records(\n                collection_name, embedmes, serialized_contexts\n            )\n            embedmes = []\n            serialized_contexts = []\n\n    if embedmes:\n        self._embed_and_add_records(collection_name, embedmes, serialized_contexts)\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.search","title":"<code>search(collection_name: str, vector: np.ndarray | List[int], k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Retrieve records from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to search</p> required <code>vector</code> <code>ndarray | List[int]</code> <p>The vector to search with</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the search</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the search.</p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def search(\n    self,\n    collection_name: str,\n    vector: np.ndarray | List[int],\n    k: int = 10,\n    filter: Optional[dict] = None,\n) -&gt; List[SerializedContext]:\n    \"\"\"\n    Retrieve records from the vector database.\n\n    Args:\n        collection_name: The name of the collection to search\n        vector: The vector to search with\n        k: The number of results to return\n        filter: Optional filter to apply to the search\n\n    Returns:\n        List of serialized contexts matching the search.\n    \"\"\"\n    return self.module.search(self.client, collection_name, vector, k, filter)\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.get_record","title":"<code>get_record(collection_name: str, record_id: str) -&gt; SerializedContext</code>","text":"<p>Get a record from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection</p> required <code>record_id</code> <code>str</code> <p>The ID of the record to retrieve</p> required <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context record.</p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def get_record(self, collection_name: str, record_id: str) -&gt; SerializedContext:\n    \"\"\"\n    Get a record from the vector database.\n\n    Args:\n        collection_name: The name of the collection\n        record_id: The ID of the record to retrieve\n\n    Returns:\n        The serialized context record.\n    \"\"\"\n    raise NotImplementedError(\n        \"get_record is not implemented for this vector database\"\n    )\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.query","title":"<code>query(query: str, k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Query the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the query</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the query.</p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def query(\n    self, query: str, k: int = 10, filter: Optional[dict] = None\n) -&gt; List[SerializedContext]:\n    \"\"\"\n    Query the vector database.\n\n    Args:\n        query: The query string\n        k: The number of results to return\n        filter: Optional filter to apply to the query\n\n    Returns:\n        List of serialized contexts matching the query.\n    \"\"\"\n    raise NotImplementedError(\"query is not implemented for this vector database\")\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.print_available_functions","title":"<code>print_available_functions(config_type: Type[VectorDatabaseConfig])</code>  <code>staticmethod</code>","text":"<p>Print the available functions for a given vector database configuration type.</p> <p>Parameters:</p> Name Type Description Default <code>config_type</code> <code>Type[VectorDatabaseConfig]</code> <p>The vector database configuration type to check</p> required Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>@staticmethod\ndef print_available_functions(config_type: Type[VectorDatabaseConfig]):\n    \"\"\"\n    Print the available functions for a given vector database configuration type.\n\n    Args:\n        config_type: The vector database configuration type to check\n    \"\"\"\n    module = importlib.import_module(config_type._module)\n    print(f\"Available functions for {config_type._module} vector database:\")\n    for name in dir(module):\n        if not name.startswith(\"_\"):\n            try:\n                inspect.signature(getattr(module, name))\n                print(f\"- {name} (available) \u2705\")\n            except NotImplementedError:\n                print(f\"- {name} (Not implemented) \u274c\")\n</code></pre>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabaseConfig","title":"<code>modaic.databases.vector_database.VectorDatabaseConfig</code>","text":"<p>Base class for vector database configurations. Each subclass must implement the <code>_module</code> class variable.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase","title":"<code>modaic.databases.vector_database.InMemoryVectorDatabase(embedder: dspy.Embedder, payload_schema: Type[BaseModel] = None, **kwargs)</code>","text":"<p>               Bases: <code>VectorDatabase</code></p> Source code in <code>src/modaic/databases/vector_database.py</code> <pre><code>def __init__(\n    self, embedder: dspy.Embedder, payload_schema: Type[BaseModel] = None, **kwargs\n):\n    from .integrations.milvus import MilvusVDBConfig\n\n    in_memory_config = MilvusVDBConfig()\n    super().__init__(in_memory_config, embedder, payload_schema, **kwargs)\n    self.data_map = {}\n</code></pre>"}]}