{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Modaic Docs","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Install Modaic</p> <pre><code>uv install modaic\n</code></pre>"},{"location":"#modaic-principles","title":"Modaic Principles","text":"<p>In Modaic there are two types of context. <code>Molecular</code> and <code>Atomic</code>. Atomic context is the finest granularity of context and is not chunkable. Molecular context is larger pieces of context that can be chunked into smaller <code>Molecular</code> or <code>Atomic</code> context objects.</p>"},{"location":"#create-a-simple-rag-framework","title":"Create a Simple RAG Framework","text":"<p>Lets create a simple agent that can answer questions about the weather.</p> <pre><code>from modaic import PrecompiledAgent, PrecompiledConfig\n\nclass WeatherConfig(PrecompiledConfig):\n    agent_type = \"WeatherAgent\" # !! This is super important so you can load the agent later!!\n\nclass WeatherAgent(PrecompiledAgent):\n    config_class = WeatherConfig # !! This is super important to link the agent to the config!!\n    def __init__(self, config: WeatherConfig, **kwargs):\n        super().__init__(config, **kwargs)\n\n    def forward(self, query: str) -&gt; str:\n        return self.get_weather(query)\n\n    def get_weather(self, city: str) -&gt; str:\n        return f\"The weather in {city} is sunny.\"\n\nagent = WeatherAgent(PrecompiledConfig())\nagent.forward(\"What is the weather in Tokyo?\")\n</code></pre>"},{"location":"#defining-your-own-context","title":"Defining your own context","text":""},{"location":"blog/","title":"Blog","text":""},{"location":"guides/context_engineering/","title":"Context Engineering with Modaic","text":"<p>Modaic comes with a powerful context engineering toolkit that is designed to be extremely flexible while still being portable and easy to use. In our SDK you have a range of context types to choose from and you can also easily define your own context class with custom behavior. From simple context classes like text and images to more complex context classes like tables, code bases, and user profiles.</p>"},{"location":"guides/context_engineering/#molecular-and-atomic-context","title":"Molecular and Atomic Context","text":"<p>Wait... why are we talking about chemistry? Good question. In Modaic we split context into two parts. Molecular and Atomic. <code>Atomic</code> context, as the name suggests, is atomic. It cannot be broken down into further parts. Some examples include text, a single image, or a single website element. <code>Molecular</code> context is a context which can be chunked into smaller parts of either <code>Atomic</code> or <code>Molecular</code> context. Like a markdown doc, a pdf, or a website. When you create a custom context class you will extend from one of these two base classes.</p>"},{"location":"guides/context_engineering/#serializedcontext","title":"SerializedContext","text":"<p>The <code>SerializedContext</code> class helps define how our context objects will be serialized and deserialized when they are stored in vector and graph databases. Every context class must define a class attribute called <code>serialized_context_class</code> which points to its to a child class of <code>SerializedContext</code> and defines what fields from your context class will be serialized and how. <code>SerializedContext</code> under the hood is a <code>pydantic.BaseModel</code> so you can use all the features of pydantic to define your serialized context class.</p>"},{"location":"guides/context_engineering/#source-tracking","title":"Source Tracking","text":"<p>All context classes automatically track their source. Throughout your entire framework. The <code>Source</code> class which is a <code>pydantic.BaseModel</code> that contains the following fields:</p> <ul> <li><code>origin: Optional[str]</code>: The filename, url, or hostname the context originates from</li> <li><code>type: Optional[SourceType]</code>: The type of origin can be one of the following:</li> <li><code>SourceType.LOCAL_PATH</code>: The context is a local file path</li> <li><code>SourceType.URL</code>: The context is a url</li> <li><code>SourceType.SQL_DB</code>: The context is a SQL database</li> <li><code>metadata: dict</code>: Source metadata that can be used to identify the context in the origin. For example, a chunk id, row id, or table id.</li> <li><code>parent: Optional[Context]</code>: A special property that is not serialized but contains a weakref to the context's parent context. </li> </ul> <p>Warning</p> <p><code>parent</code> is a weakref to the parent context object. When the parent context goes out of scope, <code>source.parent</code> will be <code>None</code>. Also, <code>parent</code> is never serialized.</p>"},{"location":"guides/context_engineering/#methods","title":"Methods","text":""},{"location":"guides/context_engineering/#predefined-methods","title":"Predefined Methods","text":"<p>All <code>Context</code> classes come with 2 main methods: <pre><code>def serialize(self) -&gt; SerializedContext:\n    \"\"\"Serialize the context into a `SerializedContext` object.\"\"\"\n</code></pre> <pre><code>@classmethod\ndef deserialize(cls, serialized: SerializedContext | dict, **kwargs) -&gt; Context:\n    \"\"\"Deserialize the context from a `SerializedContext` object. Can use kwargs to pass in additional fields to the Context constructor. \n    For example, fields that were not serialized but are needed to initialize the context. Or fields that you would like to override from the serialized context.\"\"\"\n</code></pre></p> <p>Additionally, the context classes that extend from <code>Molecular</code> have a <code>chunk_with</code> method that can be used to chunk the context into smaller parts. It has the following signature:</p> <pre><code>def chunk_with(self, chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs) -&gt; bool:\n    \"\"\"\n     Chunks a Molecular context into smaller parts of either `Atomic` or `Molecular` context. Chunks will be stored in the `.chunks` attribute.\n     Args:\n     - chunk_fn: A function that takes a context and returns a list of context objects.\n     - set_source: Whether to automatically set the source of the chunked context objects based on the parent context.\n     - **kwargs: Additional keyword arguments to pass to the chunk function.\n    \"\"\"\n</code></pre> <p>Tip</p> <p>All the above methods are automatically implemented for you when you extend from <code>Atomic</code> or <code>Molecular</code>. No need to override them. Unless you want to of course :wink:  </p>"},{"location":"guides/context_engineering/#abstract-methods","title":"Abstract Methods","text":"<p>The below methods are abstract methods that you must override when you extend from <code>Atomic</code> or <code>Molecular</code>.</p> <p><pre><code>    @abstractmethod\n    def embedme(self) -&gt; str | PIL.Image.Image:\n        \"\"\"\n        Abstract method defined by all subclasses of `Context` to define embedding behavior for embedding models.\n        Returns:\n            The string or image that should be used to embed the context.\n        \"\"\"\n</code></pre> <pre><code>    @abstractmethod\n    def readme(self) -&gt; str:\n        \"\"\"\n        Abstract method defined by all subclasses of `Context` to define readme behavior for LLMs.\n        Returns:\n            The readme string that should be read by LLMs.\n        \"\"\"\n</code></pre></p>"},{"location":"guides/context_engineering/#storage","title":"Storage","text":""},{"location":"guides/custom_context/","title":"Create A Custom Context Class","text":"<p>In this guide we will show you how to create your own context class. The context engineering toolkit in Modaic is extremely powerful and flexible. To learn more about how it works, check out the context engineering guide. In this guide we will show you how to create a custom user profile and organization profile context class for a social networking agent.</p>"},{"location":"guides/custom_context/#the-userprofile-class","title":"The UserProfile class","text":"<p>First we will define the <code>UserProfile</code> class as well as its <code>SerializedUserProfile</code> class. <pre><code>from modaic.context import Atomic, Molecular, SerializedContext\nimport requests\nfrom PIL import Image\nfrom io import BytesIO\n\n# First we define UserProfile's SerializedContext class.\n# As you can see below, only name, age, email,and description will be serialized. profile_pic will be loaded during construction.\nclass SerializedUserProfile(SerializedContext):\n    name: str\n    age: int\n    description: str\n    email: str\n\nclass UserProfile(Atomic):\n    serialized_context_class = SerializedUserProfile # !!! Super important for serialization and deserialization.\n    def __init__(self, name: str, age: int, description: str, email: str, profile_pic: PIL.Image.Image, **kwargs):\n        # All attibutes that will be serialized must match fields of SerializedUserProfile\n        super().__init__(**kwargs) # !!! Important. Allows the parent class to initalize source and metadata.\n        self.name = name \n        self.age = age\n        self.description = description\n        self.email = email\n        self.profile_pic = self.get_profile_pic()\n\n    def get_profile_pic(self) -&gt; PIL.Image.Image:\n        \"\"\"\n        Abstract method that should be implemented by all subclasses of `Atomic` to define how the profile picture should be loaded.\n        Returns:\n            The profile picture as a PIL.Image.Image object.\n        \"\"\"\n        response = requests.get(self.source.origin)\n        return Image.open(BytesIO(response.content))\n\n    # Define the abstract method embedme\n    def embedme(self) -&gt; str:\n        return self.description\n\n    # Define the abstract method readme\n    def readme(self) -&gt; str:\n        return f\"\"\"\n        User Name: {self.name}\n        Age: {self.age}\n        Email: {self.email}\n        Description: {self.description}\n        \"\"\"\n</code></pre> So what did we do here?  1. We defined the <code>UserProfile</code> class that extends from the <code>Atomic</code> context type. It has the attributes <code>name</code>, <code>age</code>, <code>description</code>, <code>email</code>, and <code>profile_pic</code>. Profile pic is dynamically loaded from the backend. 2. We defined the <code>SerializedUserProfile</code> which determines serialization behavior for the <code>UserProfile</code> class. It expects the attributes <code>name</code>, <code>age</code>, <code>description</code>, and <code>email</code>. It will ignore the <code>profile_pic</code> attribute. 3. We implemented the <code>embedme</code> method which returns the <code>description</code> of the user. 4. We implemented the <code>readme</code> method which returns a string that represents the user profile.</p> <p>Let's see what this looks like in action!</p> <p><pre><code>from modaic.databases import VectorDatabase, MilvusVDBConfig\nfrom modaic.utils import Embedder\nfrom modaic.context import Source, SourceType\nimport dspy\n\nmilvus_config = MilvusVDBConfig.from_local(file_path=\"index.db\")\nvector_db = VectorDatabase(\n    config=milvus_config,\n    embedder=Embedder(model=\"openai/text-embedding-3-small\"),\n)\n\nuser_profile1 = UserProfile(\n    name=\"John Doe\",\n    age=30,\n    description=\"John Doe is a software engineer at Google. He also loves dogs.\",\n    email=\"john.doe@gmail.com\",\n    source=Source(origin=\"https://example.com/john_doe\", type=SourceType.URL),\n)\nuser_profile2 = UserProfile(\n    name=\"Jane Smith\",\n    age=25,\n    description=\"Jane Smith is a software engineer at Meta.\",\n    email=\"jane.smith@gmail.com\",\n    source=Source(origin=\"https://example.com/jane_smith\", type=SourceType.URL),\n)\nvector_db.create_collection(\"user_profiles\", payload_schema=SerializedUserProfile)\n\n# Add records to the vector database. The `add_records` method will automatically call the `.embedme()` function and pass the result into the Embedder to embed the context.\nvector_db.add_records(\n    \"user_profiles\",\n    [user_profile1, user_profile2],\n)\n\n# Now lets search for user profiles.\nmeta_employee = vector_db.search(\n    \"user_profiles\",\n    \"Someone who works at Meta\",\n    k=1,\n)\n# This should *hopefully* return Jane Smith.\n\n# Now lets have an give us a summary of the meta employee.\n\nsummarizer = dspy.Predict(\"user_profile -&gt; summary\")\nsummarizer.set_lm(dspy.LM(model=\"openai/gpt-4o-mini\"))\n\nsummary = summarizer(user_profile=meta_employee.readme())\n</code></pre> What happened here? 1. We created two user profiles and added them to the vector database. The vector database automatically used <code>description</code> to embed the context. Since that is what <code>embedme()</code> returns 2. We fetched the <code>meta_employee</code> context from the vector database, then summarized the profile by feeding in the result of the <code>readme</code> method to a dspy.Predict module. (just a simple LLM call)</p>"},{"location":"guides/custom_context/#alternate-implementation","title":"Alternate Implementation","text":"<p>What if instead we wanted to embed users based on what they look like? All we would have to do is change the <code>embedme</code> method to return the profile picture.</p> <pre><code>def embedme(self) -&gt; PIL.Image.Image:\n    return self.profile_pic\n</code></pre>"},{"location":"guides/custom_context/#the-organizationprofile-class","title":"The OrganizationProfile class","text":"<p>Now that we have a <code>UserProfile</code> class, we can create an <code>OrganizationProfile</code> class. That is composed of multiple <code>UserProfile</code>s. Since UserProfile can be chunked, it is a good idea to make it extend the <code>Molecular</code> context type.</p> <pre><code>from modaic.context import Molecular\nimport requests\n\nclass SerializedOrganizationProfile(SerializedContext):\n    name: str\n    website_url: str\n\nclass OrganizationProfile(Molecular):\n    def __init__(self, name: str, website_url: str, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.website_url = website_url\n    # We won't define a proper embedme since we aren't going to be embedding organization profiles.\n    def embedme(self) -&gt; str: \n        pass\n\n    def readme(self) -&gt; str:\n        return f\"\"\"\n        Organization Name: {self.name}\n        Description: {self.description}\n        \"\"\"\n\n    # We will also define a method that fetches an organization profile from a url.\n    @staticmethod\n    def from_url(url: str) -&gt; OrganizationProfile:\n        org = requests.get(url).json().data\n        return OrganizationProfile(**org)\n\ndef chunk_by_user(org_profile: OrganizationProfile) -&gt; list[UserProfile]:\n    users = requests.get(f'{org_profile.source.origin}/users').json().data\n    return [UserProfile(**user) for user in users]\n\n# Now lets create an organization profile.\norg_profile1 = OrganizationProfile(\n    name=\"Google\",\n    description=\"Google is a search engine company.\",\n    source=Source(origin=\"https://api.example.com/google\", type=SourceType.URL),\n)\norg_profile2 = OrganizationProfile(\n    name=\"Meta\",\n    description=\"Meta is a social networking company.\",\n    source=Source(origin=\"https://api.example.com/meta\", type=SourceType.URL),\n)\n\nvector_db.create_collection(\"user_profiles\", payload_schema=SerializedOrganizationProfile)\n\norg_profile1.chunk_with(chunk_fn=chunk_by_user)\norg_profile2.chunk_with(chunk_fn=chunk_by_user)\n\nvector_db.add_records(\n    \"user_profiles\",\n    org_profile1.chunks + org_profile2.chunks,\n)\n\n# Now lets search for user profiles.\ndog_lover = vector_db.search(\n    \"user_profiles\",\n    \"Someone who loves dogs\",\n    k=1,\n)\n\n# We can use the source attribute to get the organization this profile belongs to.\norg_url = dog_lover.source.origin\norg_profile = OrganizationProfile.from_url(org_url)\n</code></pre>"},{"location":"guides/custom_context/#advanced-usage-grabbing-values-at-serialization-time","title":"Advanced Usage: Grabbing values at serialization time","text":"<p>Lets say we want to add a last accessed timestamp to out user profile for filtering in the vector database. <pre><code>import datetime\n\nclass SerializedUserProfile(SerializedContext):\n    name: str\n    age: int\n    description: str\n    email: str\n    last_accessed: str\n\nclass UserProfile(Molecular):\n    def __init__(self, name: str, age: int, description: str, email: str, last_accessed: datetime.datetime, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.age = age\n        self.description = description\n        self.email = email\n        self.last_accessed = datetime.datetime.now().isoformat()\n</code></pre> We have a problem! <code>last_accessed</code> will refer to the time of constructution, not of serialization. The solution? We can actually add the output of functions to <code>SerializedUserProfile</code> as long as they are can be called with no arguments. <pre><code>class SerializedUserProfile(SerializedContext):\n    name: str\n    age: int\n    description: str\n    email: str\n    last_accessed: str\n\nclass UserProfile(Molecular):\n    def __init__(self, name: str, age: int, description: str, email: str, last_accessed: datetime.datetime, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.age = age\n        self.description = description\n        self.email = email\n\n    def last_accessed(self) -&gt; str:\n        return datetime.datetime.now().isoformat()\n</code></pre></p> <p>the <code>serialize</code> funtion will automatically look for a function names <code>last_accessed</code> and call it to get the value of <code>last_accessed</code> during serialization.</p>"},{"location":"reference/precompiled_agent/","title":"PrecompiledAgent","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent","title":"<code>modaic.precompiled_agent.PrecompiledAgent</code>","text":"<p>Bases: <code>dspy.Module</code></p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.forward","title":"<code>forward(**kwargs) -&gt; str</code>","text":"<p>Forward pass for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Forward pass result.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the agent and the config to the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the agent and config to. Must be a local path.</p> required"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.from_precompiled","title":"<code>from_precompiled(path: str, **kwargs) -&gt; PrecompiledAgent</code>  <code>classmethod</code>","text":"<p>Loads the agent and the config from the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the agent and config from. Can be a local path or a path on Modaic Hub.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PrecompiledAgent</code> <p>An instance of the PrecompiledAgent class.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.push_to_hub","title":"<code>push_to_hub(repo_id: str) -&gt; None</code>","text":"<p>Pushes the agent and the config to the given repo_id.</p> <p>Parameters:</p> Name Type Description Default <code>repo_id</code> <code>str</code> <p>The path on Modaic hub to save the agent and config to.</p> required"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig","title":"<code>modaic.precompiled_agent.PrecompiledConfig</code>","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the config to a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the config to.</p> required"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_precompiled","title":"<code>from_precompiled(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_dict","title":"<code>from_dict(dict: Dict) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <code>Dict</code> <p>A dictionary containing the config.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_json","title":"<code>from_json(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p>"},{"location":"reference/context/context/","title":"Context","text":""},{"location":"reference/context/context/#modaic.context.Context","title":"<code>modaic.context.Context</code>","text":""},{"location":"reference/context/context/#modaic.context.Context.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/context/#modaic.context.Context.readme","title":"<code>readme() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how LLMs should read the context.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string that should be read by LLMs.</p>"},{"location":"reference/context/context/#modaic.context.Context.serialize","title":"<code>serialize() -&gt; SerializedContext</code>","text":"<p>Serializes the context object into its associated <code>SerializedContext</code> object. Defined at self.serialized_context_class.</p> <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Context.deserialize","title":"<code>deserialize(serialized: SerializedContext | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>SerializedContext</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializedContext | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the SerializedContext object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Context.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Context.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Context.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/context/#modaic.context.Context.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic","title":"<code>modaic.context.Atomic</code>","text":"<p>Base class for all Atomic Context objects. Atomic objects represent context at its finest granularity and are not chunkable.</p> Example <p>In this example, <code>CaptionedImage</code> is an <code>Atomic</code> context object that stores the caption and the caption embedding. <pre><code>from modaic.context import SerializedContext\nfrom modaic.types import String, Vector, Float16Vector\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float16Vector[384]\n    image_path: String[100]\n\nclass CaptionedImage(Atomic):\n    serialized_context_class = SerializedCaptionedImage\n\n    def __init__(self, image_path: str, caption: str, caption_embedding: np.ndarray, **kwargs):\n        super().__init__(**kwargs)\n        self.caption = caption\n        self.caption_embedding = caption_embedding\n        self.image_path = image_path\n        self.image = PIL.Image.open(image_path)\n\n    def embedme(self) -&gt; PIL.Image.Image:\n        return self.image\n</code></pre></p>"},{"location":"reference/context/context/#modaic.context.Atomic.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.readme","title":"<code>readme() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how LLMs should read the context.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string that should be read by LLMs.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.serialize","title":"<code>serialize() -&gt; SerializedContext</code>","text":"<p>Serializes the context object into its associated <code>SerializedContext</code> object. Defined at self.serialized_context_class.</p> <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.deserialize","title":"<code>deserialize(serialized: SerializedContext | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>SerializedContext</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializedContext | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the SerializedContext object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Atomic.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Atomic.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular","title":"<code>modaic.context.Molecular</code>","text":"<p>Base class for all <code>Molecular</code> Context objects. <code>Molecular</code> context objects represent context that can be chunked into smaller <code>Molecular</code> or <code>Atomic</code> context objects.</p> Example <p>In this example, <code>MarkdownDoc</code> is a <code>Molecular</code> context object that stores a markdown document. <pre><code>from modaic.context import Molecular\nfrom modaic.types import String, Vector, Float16Vector\nfrom langchain_text_splitters import MarkdownTextSplitter\nfrom modaic.context import Text\n\nclass SerializedMarkdownDoc(SerializedContext):\n    markdown: String\n\nclass MarkdownDoc(Molecular):\n    serialized_context_class = SerializedMarkdownDoc\n\n    def chunk(self):\n        # Split the markdown into chunks of 1000 characters\n        splitter = MarkdownTextSplitter()\n        chunk_fn = lambda mdoc: [Text(text=t) for t in splitter.split_text(mdoc.markdown)]\n        self.chunk_with(chunk_fn)\n\n    def __init__(self, markdown: str, **kwargs):\n        super().__init__(**kwargs)\n        self.markdown = markdown\n</code></pre></p>"},{"location":"reference/context/context/#modaic.context.Molecular.chunks","title":"<code>chunks: List[Context]</code>  <code>property</code>","text":"<p>The list of chunks.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.readme","title":"<code>readme() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how LLMs should read the context.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string that should be read by LLMs.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.serialize","title":"<code>serialize() -&gt; SerializedContext</code>","text":"<p>Serializes the context object into its associated <code>SerializedContext</code> object. Defined at self.serialized_context_class.</p> <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.deserialize","title":"<code>deserialize(serialized: SerializedContext | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>SerializedContext</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializedContext | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the SerializedContext object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Molecular.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Molecular.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/context/#modaic.context.Molecular.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/context/serialized_context/","title":"SerializedContext","text":""},{"location":"reference/context/serialized_context/#modaic.context.SerializedContext","title":"<code>modaic.context.SerializedContext</code>","text":"<p>Base class used to define the schema of a context object when they are serialized.</p> <p>Attributes:</p> Name Type Description <code>context_class</code> <code>str</code> <p>The class of the context object that this serialized context is for.</p> <code>id</code> <code>str</code> <p>The id of the serialized context.</p> <code>source</code> <code>Source</code> <p>The source of the context object.</p> <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> Example <p>In this example, <code>SerializedCaptionedImage</code> stores the caption and the caption embedding while <code>CaptionedImage</code> is the <code>Context</code> class that is used to store the context object. Note that the image is loaded dynamically in the <code>CaptionedImage</code> class and is not serialized to <code>SerializedCaptionedImage</code>. <pre><code>from modaic.context import SerializedContext\nfrom modaic.types import String, Vector, Float16Vector\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float16Vector[384]\n    image_path: String[100]\n\nclass CaptionedImage(Atomic):\n    serialized_context_class = SerializedCaptionedImage\n\n    def __init__(self, image_path: str, caption: str, caption_embedding: np.ndarray, **kwargs):\n        super().__init__(**kwargs)\n        self.caption = caption\n        self.caption_embedding = caption_embedding\n        self.image_path = image_path\n        self.image = PIL.Image.open(image_path)\n\n    def embedme(self) -&gt; PIL.Image.Image:\n        return self.image\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types","title":"<code>modaic.types</code>","text":""},{"location":"reference/context/serialized_context/#modaic.types.Vector","title":"<code>Vector</code>","text":"<p>float vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Vector[dim]</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Required. The dimension of the vector.</p> required Example <p>The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption. <pre><code>from modaic.types import Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.Float16Vector","title":"<code>Float16Vector</code>","text":"<p>float16 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Float16Vector[dim]</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Required. The dimension of the vector.</p> required Example <pre><code>from modaic.types import Float16Vector\nfrom modaic.context import SerializedContext\n\n# Case where we want to store a secondary embedding for the caption of an image.\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float16Vector[384]\n</code></pre>"},{"location":"reference/context/serialized_context/#modaic.types.Float32Vector","title":"<code>Float32Vector</code>","text":"<p>float32 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Float32Vector[dim]</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Required. The dimension of the vector.</p> required Example <p>The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption. <pre><code>from modaic.types import Float32Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float32Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.Float64Vector","title":"<code>Float64Vector</code>","text":"<p>float64 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with Float64Vector[dim]</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Required. The dimension of the vector.</p> required Example <p>The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption. <pre><code>from modaic.types import Float64Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: Float64Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.BFloat16Vector","title":"<code>BFloat16Vector</code>","text":"<p>bfloat16 vector field type for <code>SerializedContext</code> of the given dimension. Must be created with BFloat16Vector[dim]</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Required. The dimension of the vector.</p> required Example <p>The <code>SerializedContext</code> class for a <code>CaptionedImage</code> Context type that stores both a primary embedding using the image and a secondary embedding using the caption. <pre><code>from modaic.types import BFloat16Vector\nfrom modaic.context import SerializedContext\n\nclass SerializedCaptionedImage(SerializedContext):\n    caption: String[100]\n    caption_embedding: BFloat16Vector[384]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.BinaryVector","title":"<code>BinaryVector</code>","text":"<p>binary vector field type for <code>SerializedContext</code> of the given dimension. Must be created with BinaryVector[dim]</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>Required. The dimension of the vector.</p> required Example <p>The <code>SerializedContext</code> class for a <code>SenateBill</code> Context type that uses a binary vector to store the vote distribution. <pre><code>from modaic.types import BinaryVector\nfrom modaic.context import SerializedContext\n\nclass SerializedSenateBill(SerializedContext):\n    bill_id: int\n    bill_title: String[10]\n    bill_description: String\n    vote_distribution: BinaryVector[100]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.Array","title":"<code>Array</code>","text":"<p>Array field type for <code>SerializedContext</code>. Must be created with Array[dtype, max_size]</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>Type</code> <p>The type of the elements in the array.</p> required <code>max_size</code> <code>int</code> <p>The maximum size of the array.</p> required Example <p>A <code>SerializedEmail</code> for <code>Email</code> context class that stores an email's content and recipients. <pre><code>from modaic.types import Array\nfrom modaic.context import SerializedContext\n\nclass SerializedEmail(SerializedContext):\n    content: str\n    recipients: Array[str, 100]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.String","title":"<code>String</code>","text":"<p>String type that can be parameterized with max_length constraint.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>The maximum length of the string.</p> required Example <pre><code>from modaic.types import String\nfrom modaic.context import SerializedContext\n\nclass SerializedEmail(SerializedContext):\n    subject: String[100]\n    content: str\n    recipients: Array[str, 100]\n</code></pre>"},{"location":"reference/context/table/","title":"Table","text":"<p>handler: python</p> <p>handler: python</p>"},{"location":"reference/context/table/#modaic.context.table.Table","title":"<code>modaic.context.table.Table</code>","text":"<p>A molecular context object that represents a table. Can be queried with SQL.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.chunks","title":"<code>chunks: List[Context]</code>  <code>property</code>","text":"<p>The list of chunks.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.__init__","title":"<code>__init__(df: pd.DataFrame, name: str, prepare_for_sql: bool = True, **kwargs)</code>","text":"<p>Initializes a Table context object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to represent as a table.</p> required <code>name</code> <code>str</code> <p>The name of the table.</p> required <code>prepare_for_sql</code> <code>bool</code> <p>Whether to prepare the table for SQL queries.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Molecular context object.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.Table.get_col","title":"<code>get_col(col_name: str) -&gt; pd.Series</code>","text":"<p>Gets a single column from the table.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the column to get</p> required <p>Returns:</p> Type Description <code>Series</code> <p>The specified column as a pandas Series.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.get_schema_with_samples","title":"<code>get_schema_with_samples()</code>","text":"<p>Returns a dictionary of mapping column names to dictionaries containing the column type and sample values.</p> Example <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]})\n&gt;&gt;&gt; table = Table(df, name=\"table\")\n&gt;&gt;&gt; table.get_schema_with_samples()\n{\"Column1\": {\"type\": \"INT\", \"sample_values\": [1, 2, 3]}, \"Column2\": {\"type\": \"INT\", \"sample_values\": [4, 5, 6]}, \"Column3\": {\"type\": \"INT\", \"sample_values\": [7, 8, 9]}}\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.query","title":"<code>query(query: str)</code>","text":"<p>Queries the table. All queries run should refer to the table as <code>this</code> or <code>This</code></p>"},{"location":"reference/context/table/#modaic.context.table.Table.markdown","title":"<code>markdown() -&gt; str</code>","text":"<p>Converts the table to markdown format. Returns a markdown representation of the table with the table name as header.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.readme","title":"<code>readme()</code>","text":"<pre><code>    readme method for table. Returns a markdown representation of the table.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]})\n        &gt;&gt;&gt; table = Table(df, name=\"table\")\n        &gt;&gt;&gt; table.readme()\n        \"Table name: table\n</code></pre> <p>\"             \" | Column1 | Column2 | Column3 |  \"             \" | --- | --- | --- |  \"             \" | 1 | 2 | 3 |  \"             \" | 4 | 5 | 6 |  \"             \" | 7 | 8 | 9 |  \"             ```</p>"},{"location":"reference/context/table/#modaic.context.table.Table.embedme","title":"<code>embedme()</code>","text":"<p>embedme method for table. Returns a markdown representation of the table.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.serialize","title":"<code>serialize() -&gt; SerializedContext</code>","text":"<p>Serializes the context object into its associated <code>SerializedContext</code> object. Defined at self.serialized_context_class.</p> <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.deserialize","title":"<code>deserialize(serialized: SerializedContext | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>SerializedContext</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializedContext | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the SerializedContext object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.Table.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.Table.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.Table.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable","title":"<code>modaic.context.table.MultiTabbedTable</code>","text":""},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.chunks","title":"<code>chunks: List[Context]</code>  <code>property</code>","text":"<p>The list of chunks.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.init_sql","title":"<code>init_sql()</code>","text":"<p>Initilizes and in memory sql database for querying</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.close_sql","title":"<code>close_sql()</code>","text":"<p>Closes the in memory sql database</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.query","title":"<code>query(query: str)</code>","text":"<p>Queries the in memory sql database</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.readme","title":"<code>readme() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how LLMs should read the context.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string that should be read by LLMs.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.serialize","title":"<code>serialize() -&gt; SerializedContext</code>","text":"<p>Serializes the context object into its associated <code>SerializedContext</code> object. Defined at self.serialized_context_class.</p> <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.deserialize","title":"<code>deserialize(serialized: SerializedContext | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>SerializedContext</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializedContext | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the SerializedContext object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/context/text/","title":"Text","text":"<p>handler: python</p> <p>handler: python</p>"},{"location":"reference/context/text/#modaic.context.text.Text","title":"<code>modaic.context.text.Text</code>","text":""},{"location":"reference/context/text/#modaic.context.text.Text.serialize","title":"<code>serialize() -&gt; SerializedContext</code>","text":"<p>Serializes the context object into its associated <code>SerializedContext</code> object. Defined at self.serialized_context_class.</p> <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.Text.deserialize","title":"<code>deserialize(serialized: SerializedContext | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>SerializedContext</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializedContext | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the SerializedContext object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.Text.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.Text.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.Text.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/text/#modaic.context.text.Text.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText","title":"<code>modaic.context.text.LongText</code>","text":""},{"location":"reference/context/text/#modaic.context.text.LongText.chunk_text","title":"<code>chunk_text(chunk_fn: Callable[[str], List[str | tuple[str, dict]]]) -&gt; List[Text]</code>","text":"<p>Chunk the text into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>Callable[[str], List[str | tuple[str, dict]]]</code> <p>A function that takes in a string and returns a list of strings or string-metadata pairs.</p> required <p>Returns:</p> Type Description <code>List[Text]</code> <p>A list of Context objects.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.serialize","title":"<code>serialize() -&gt; SerializedContext</code>","text":"<p>Serializes the context object into its associated <code>SerializedContext</code> object. Defined at self.serialized_context_class.</p> <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.deserialize","title":"<code>deserialize(serialized: SerializedContext | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>SerializedContext</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>SerializedContext | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the SerializedContext object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.LongText.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.LongText.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/text/#modaic.context.text.LongText.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/databases/sql_database/","title":"SQL Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase","title":"<code>modaic.databases.sql_database.SQLDatabase</code>","text":""},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.drop_table","title":"<code>drop_table(name: str, must_exist: bool = False)</code>","text":"<p>Drop a table from the database and remove its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to drop</p> required"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.list_tables","title":"<code>list_tables()</code>","text":"<p>List all tables currently in the database.</p> <p>Returns:</p> Type Description <p>List of table names in the database.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_schema","title":"<code>get_table_schema(name: str)</code>","text":"<p>Return column schema for a given table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get schema for</p> required <p>Returns:</p> Type Description <p>Column schema information for the table.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_metadata","title":"<code>get_table_metadata(name: str) -&gt; dict</code>","text":"<p>Get metadata for a specific table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get metadata for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the table's metadata, or empty dict if not found.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.from_dir","title":"<code>from_dir(dir_path: str, config: SQLDatabaseConfig)</code>  <code>classmethod</code>","text":"<p>Initializes a new SQLDatabase from a directory of files.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>Path to the directory containing files to load</p> required <code>config</code> <code>SQLDatabaseConfig</code> <p>SQL database configuration</p> required <p>Returns:</p> Type Description <p>New SQLDatabase instance loaded with data from the directory.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.connect","title":"<code>connect()</code>","text":"<p>Context manager for database connections. Reuses existing connection if available, otherwise creates a temporary one.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.open_persistent_connection","title":"<code>open_persistent_connection()</code>","text":"<p>Opens a persistent connection that will be reused across operations. Call close() to close the persistent connection.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.close","title":"<code>close()</code>","text":"<p>Closes the current connection if one exists.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.begin","title":"<code>begin()</code>","text":"<p>Context manager for database transactions using existing connection. Requires an active connection. Commits on success, rolls back on exception.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no active connection exists</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.connect_and_begin","title":"<code>connect_and_begin()</code>","text":"<p>Context manager that establishes a connection and starts a transaction. Reuses existing connection if available, otherwise creates a temporary one. Commits on success, rolls back on exception.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLServerConfig","title":"<code>modaic.databases.sql_database.SQLServerConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a SQL served over a port or remote connection. (MySQL, PostgreSQL, etc.)</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The username to connect to the database.</p> required <code>password</code> <code>str</code> <p>The password to connect to the database.</p> required <code>host</code> <code>str</code> <p>The host of the database.</p> required <code>database</code> <code>str</code> <p>The name of the database.</p> required <code>port</code> <code>Optional[str]</code> <p>The port of the database.</p> <code>None</code>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLiteConfig","title":"<code>modaic.databases.sql_database.SQLiteConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Optional[str]</code> <p>Path to the SQLite database file.</p> <code>None</code> <code>in_memory</code> <code>bool</code> <p>Whether to create an in-memory SQLite database.</p> <code>False</code> <code>query_params</code> <code>Optional[dict]</code> <p>Query parameters to pass to the database.</p> <code>None</code>"},{"location":"reference/databases/vector_database/","title":"Vector Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase","title":"<code>modaic.databases.vector_database.VectorDatabase</code>","text":""},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.__init__","title":"<code>__init__(config: VectorDatabaseConfig, embedder: Embedder, payload_schema: Type[BaseModel] = None, **kwargs)</code>","text":"<p>Initialize a vanilla vector database. This is a base class for all vector databases. If you need more functionality from a specific vector database, you should use a specific subclass.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>VectorDatabaseConfig</code> <p>The configuration for the vector database</p> required <code>embedder</code> <code>Embedder</code> <p>The embedder to use for the vector database</p> required <code>payload_schema</code> <code>Type[BaseModel]</code> <p>The Pydantic schema for validating context metadata</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.create_collection","title":"<code>create_collection(collection_name: str, payload_schema: Optional[Type[BaseModel]] = None, embedding_dim: Optional[int] = None, exists_behavior: Literal['fail', 'replace', 'append'] = 'replace')</code>","text":"<p>Create a collection in the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create</p> required <code>payload_schema</code> <code>Optional[Type[BaseModel]]</code> <p>The schema of the collection</p> <code>None</code> <code>exists_behavior</code> <code>Literal['fail', 'replace', 'append']</code> <p>The behavior when the collection already exists</p> <code>'replace'</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.add_records","title":"<code>add_records(collection_name: str, records: Iterable[Context | Tuple[str, SerializedContext]], batch_size: Optional[int] = None)</code>","text":"<p>Add items to a collection in the vector database. Uses the Context's get_embed_context() method and the embedder to create embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to add records to</p> required <code>records</code> <code>Iterable[Context | Tuple[str, SerializedContext]]</code> <p>The records to add to the collection</p> required <code>batch_size</code> <code>Optional[int]</code> <p>Optional batch size for processing records</p> <code>None</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.search","title":"<code>search(collection_name: str, vector: np.ndarray | List[int], k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Retrieve records from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to search</p> required <code>vector</code> <code>ndarray | List[int]</code> <p>The vector to search with</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the search</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the search.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.get_record","title":"<code>get_record(collection_name: str, record_id: str) -&gt; SerializedContext</code>","text":"<p>Get a record from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection</p> required <code>record_id</code> <code>str</code> <p>The ID of the record to retrieve</p> required <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context record.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.query","title":"<code>query(query: str, k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Query the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the query</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the query.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.print_available_functions","title":"<code>print_available_functions(config_type: Type[VectorDatabaseConfig])</code>  <code>staticmethod</code>","text":"<p>Print the available functions for a given vector database configuration type.</p> <p>Parameters:</p> Name Type Description Default <code>config_type</code> <code>Type[VectorDatabaseConfig]</code> <p>The vector database configuration type to check</p> required"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabaseConfig","title":"<code>modaic.databases.vector_database.VectorDatabaseConfig</code>","text":"<p>Base class for vector database configurations. Each subclass must implement the <code>_module</code> class variable.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase","title":"<code>modaic.databases.vector_database.InMemoryVectorDatabase</code>","text":""},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.create_collection","title":"<code>create_collection(collection_name: str, payload_schema: Optional[Type[BaseModel]] = None, embedding_dim: Optional[int] = None, exists_behavior: Literal['fail', 'replace', 'append'] = 'replace')</code>","text":"<p>Create a collection in the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create</p> required <code>payload_schema</code> <code>Optional[Type[BaseModel]]</code> <p>The schema of the collection</p> <code>None</code> <code>exists_behavior</code> <code>Literal['fail', 'replace', 'append']</code> <p>The behavior when the collection already exists</p> <code>'replace'</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.search","title":"<code>search(collection_name: str, vector: np.ndarray | List[int], k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Retrieve records from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to search</p> required <code>vector</code> <code>ndarray | List[int]</code> <p>The vector to search with</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the search</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the search.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.get_record","title":"<code>get_record(collection_name: str, record_id: str) -&gt; SerializedContext</code>","text":"<p>Get a record from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection</p> required <code>record_id</code> <code>str</code> <p>The ID of the record to retrieve</p> required <p>Returns:</p> Type Description <code>SerializedContext</code> <p>The serialized context record.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.query","title":"<code>query(query: str, k: int = 10, filter: Optional[dict] = None) -&gt; List[SerializedContext]</code>","text":"<p>Query the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the query</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SerializedContext]</code> <p>List of serialized contexts matching the query.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.print_available_functions","title":"<code>print_available_functions(config_type: Type[VectorDatabaseConfig])</code>  <code>staticmethod</code>","text":"<p>Print the available functions for a given vector database configuration type.</p> <p>Parameters:</p> Name Type Description Default <code>config_type</code> <code>Type[VectorDatabaseConfig]</code> <p>The vector database configuration type to check</p> required"}]}