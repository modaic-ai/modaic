{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Modaic Docs","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Install Modaic</p> <p><pre><code>uv add modaic\n</code></pre> or</p> <pre><code>pip install modaic\n</code></pre>"},{"location":"#modaic-principles","title":"Modaic Principles","text":"<p>In Modaic there are two types of context. <code>Molecular</code> and <code>Atomic</code>. Atomic context is the finest granularity of context and is not chunkable. Molecular context is larger pieces of context that can be chunked into smaller <code>Molecular</code> or <code>Atomic</code> context objects.</p>"},{"location":"#create-a-simple-rag-framework","title":"Create a Simple RAG Framework","text":"<p>Lets create a simple agent that can answer questions about the weather.</p> <p><pre><code>from modaic import PrecompiledAgent, PrecompiledConfig\nimport dspy\n\nclass WeatherConfig(PrecompiledConfig):\n    agent_type = \"WeatherAgent\" # !! This is super important so you can load the agent later!!\n\nclass WeatherAgent(PrecompiledAgent):\n    config_class = WeatherConfig # !! This is super important to link the agent to the config!!\n    def __init__(self, config: WeatherConfig, **kwargs):\n        super().__init__(config, **kwargs)\n        self.summarize = dspy.ReAct(signature=\"question-&gt;answer\", tools=[self.get_weather])\n\n    def forward(self, query: str) -&gt; str:\n        return self.summarize(query)\n\n    def get_weather(self, city: str) -&gt; str:\n        \"\"\"\n        Get the weather in a city.\n        \"\"\"\n        return f\"The weather in {city} is sunny.\"\n\nagent = WeatherAgent(PrecompiledConfig())\nagent(\"What is the weather in Tokyo?\")\nprint(response)\n</code></pre> Response: <pre><code>Prediction(\n    trajectory={'thought_0': 'I need to get the current weather information for Tokyo to answer the question.', 'tool_name_0': 'get_weather', 'tool_args_0': {'city': 'Tokyo'}, 'observation_0': 'The weather in Tokyo is sunny.', 'thought_1': 'I have obtained the weather information for Tokyo, which is sunny. Now I can finalize my response to the question.', 'tool_name_1': 'finish', 'tool_args_1': {}, 'observation_1': 'Completed.'},\n    reasoning='The current weather information for Tokyo has been obtained, indicating that it is sunny. This directly answers the question about the weather in Tokyo.',\n    answer='The weather in Tokyo is sunny.'\n)\n</code></pre> <pre><code># Push agent to the hub (optional)\nagent.push_to_hub(\"modaic/weather-agent\")\n</code></pre></p>"},{"location":"#using-the-context-engineering-toolkit","title":"Using the Context Engineering Toolkit","text":"<p>Here we define an Indexer that ingests txt or md files, chunks them, then adds them to a vector database. <pre><code>import modaic\nfrom modaic.context import LongText, Text\nfrom modaic.databases import MilvusVDBConfig\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\n\nclass MyIndexer(modaic.Indexer):\n    def __init__(\n        self, vdb_config: MilvusVDBConfig, *args, **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n        self.embedder = modaic.Embedder(model=\"openai/text-embedding-3-small\")\n        self.vector_database = VectorDatabase(\n            config=vdb_config,\n            embedder=self.embedder,\n        )\n        self.sql_db = SQLDatabase(config=sql_config)\n        self.text_splitter = RecursiveCharacterTextSplitter(\n            chunk_size=1000,\n            chunk_overlap=200,\n        )\n\n        self.vector_database.create_collection(\n            \"docs\", Text.schema, if_exists=\"replace\"\n        )\n\n    def ingest(self, files: List[str]):\n        records = []\n        for file in files:\n            with open(file, \"r\", encoding=\"utf-8\") as f:\n                text = f.read()\n            text_document = LongText(text=text)\n            text_document.chunk_text(self.text_splitter.split_text)\n            records.extend(text_document.get_chunks())\n        self.vector_database.add_records(\"docs\", records)\n    def retrieve(self, query: str, k: int = 10) -&gt; List[Text]:\n        return self.vector_database.retrieve(query, k)\n</code></pre></p>"},{"location":"#define-your-own-context-class","title":"Define your own Context Class","text":"<p>You can also define your own context in modaic. Here we define a <code>UserProfile</code> context class that is an <code>Atomic</code> context. Which means it is not chunkable.</p> <p><pre><code>from modaic.context import Atomic, Molecular, ContextSchema\nimport requests\nfrom PIL import Image\nfrom io import BytesIO\n\n# First we define UserProfile's ContextSchema class.\n# As you can see below, only name, age, email,and description will be serialized. profile_pic will only be loaded during construction.\nclass UserProfileSchema(ContextSchema):\n    name: str\n    age: int\n    description: str\n    email: str\n\nclass UserProfile(Atomic):\n    schema = UserProfileSchema # !!! Super important for serialization and deserialization.\n    def __init__(self, name: str, age: int, description: str, email: str, profile_pic: PIL.Image.Image, **kwargs):\n        # All attibutes that will be serialized must match fields of UserProfileSchema\n        super().__init__(**kwargs) # !!! Important. Allows the parent class to initalize source and metadata.\n        self.name = name \n        self.age = age\n        self.description = description\n        self.email = email\n        self.profile_pic = self.get_profile_pic()\n\n    def get_profile_pic(self) -&gt; PIL.Image.Image:\n        response = requests.get(self.source.origin)\n        data = response.json()\n        img_response = requests.get(data[\"profile_pic\"])\n        return Image.open(BytesIO(img_response.content))\n\n    # Define the abstract method embedme\n    def embedme(self) -&gt; str:\n        return self.description\n\n    # Define the readme method.\n    # We don't explicitly need to do this since by default the readme method will return self.serialize()\n    # However, its useful to override when you need custom behavior.\n    def readme(self) -&gt; str:\n        return f\"\"\"\n        User Name: {self.name}\n        Age: {self.age}\n        Email: {self.email}\n        Description: {self.description}\n        \"\"\"\n</code></pre> So what did we do here?</p> <ol> <li> <p>We defined the UserProfile class that extends from the Atomic context type. It has the attributes name, age, description, email, and profile_pic. Profile pic is dynamically loaded from the backend.</p> </li> <li> <p>We defined the UserProfileSchema which determines serialization behavior for the UserProfile class. It expects the attributes name, age, description, and email. It will ignore the profile_pic attribute.</p> </li> <li> <p>We implemented the embedme method which returns the description of the user.</p> </li> <li> <p>We implemented the readme method which returns a string that represents the user profile.</p> </li> </ol>"},{"location":"#bringing-it-all-together","title":"Bringing it all together","text":"<p>Lets define a networking agent that emails users you may be interested in meeting.</p> <p>First lets define an indexer for the user profiles.</p> <pre><code>from modaic.context import LongText, Text\nfrom modaic.databases import MilvusVDBConfig\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\n\nclass UserProfileIndexer(Indexer):\n    def __init__(\n        self, vdb_config: MilvusVDBConfig, *args, **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n        self.embedder = modaic.Embedder(model=\"openai/text-embedding-3-small\")\n        self.vector_database = VectorDatabase(\n            config=vdb_config,\n            embedder=self.embedder,\n        )\n        self.vector_database.create_collection(\n            \"user_profiles\", UserProfile.schema, if_exists=\"append\"\n        )\n    def ingest(self, user_profiles: List[dict]):\n        records = []\n        for user_profile in user_profiles:\n            user_profile = UserProfile(**user_profile)\n            records.append(user_profile)\n        self.vector_database.add_records(\"user_profiles\", records)\n\n    def retrieve(self, query: str, k: int = 10) -&gt; List[UserProfileSchema]:\n        return self.vector_database.retrieve(query, k)\n</code></pre> <p>Now lets define the NetworkingAgent.</p> <p><pre><code>from modaic import PrecompiledAgent, PrecompiledConfig\nimport dspy\n\nclass NetworkingAgentConfig(PrecompiledConfig):\n    agent_type = \"NetworkingAgent\" # !! This is super important so you can load the agent later!!\n    milvus_config: MilvusVDBConfig\n\n\nclass NetworkingAgent(PrecompiledAgent):\n    config_class = NetworkingAgentConfig # !! This is super important to link the agent to the config!!\n    def __init__(self, config: NetworkingAgentConfig, **kwargs):\n        super().__init__(config, **kwargs)\n        self.networker = dspy.ReAct(signature=\"question-&gt;answer\", tools=[self.send_email, self.get_user_profiles])\n        self.indexer = UserProfileIndexer(config.milvus_config)\n\n    def forward(self, query: str) -&gt; str:\n        return self.networker(query)\n\n    def send_email(self, email: str, message: str) -&gt; str:\n        \"\"\"\n        Send an email to a user.\n        \"\"\"\n        # The Doc string above will describe the tool to the ReAct agent.\n        return f\"Email sent to {email} with message: {message}\"\n\n    def get_user_profiles(self, query: str) -&gt; List[UserProfileSchema]:\n        \"\"\"\n        Gets user profiles that match the query.\n        \"\"\"\n        return self.indexer.retrieve(query, k=10)\n\n    def ingest_user_profiles(self, user_profiles: List[dict]):\n        \"\"\"\n        Ingests user profiles into the indexer.\n        \"\"\"\n        self.indexer.ingest(user_profiles)\n\nconfig = NetworkingAgentConfig(milvus_config=MilvusVDBConfig.from_local(\"index.db\"))\nagent = NetworkingAgent(config)\n</code></pre> We'll add some user profiles to the indexer.</p> <p><pre><code>user_profiles = [\n    {\n        \"name\": \"John Doe\",\n        \"age\": 30,\n        \"description\": \"John is a designer\",\n        \"email\": \"john.doe@example.com\",\n    },\n    {\n        \"name\": \"Jane Doe\",\n        \"age\": 25,\n        \"description\": \"Jane is a software engineer\",\n        \"email\": \"jane.doe@example.com\",\n    },\n]\nagent.ingest_user_profiles(user_profiles)\n</code></pre> Now lets test it out. <pre><code>response = agent(question=\"Which user is a software engineer like me?\")\nprint(response)\n</code></pre></p> <p>Response: <pre><code>Prediction(\n    trajectory={'thought_0': 'I need to find user profiles that match the description of being a software engineer. This will help identify users who share a similar profession.', 'tool_name_0': 'get_user_profiles', 'tool_args_0': {'description': 'software engineer'}, 'observation_0': [UserProfile(name='John Doe', age=30, description='John is a designer', email='john.doe@example.com'), UserProfile(name='Jane Doe', age=25, description='Jane is a software engineer', email='jane.doe@example.com')], 'thought_1': 'I found one user, Jane Doe, who is a software engineer. I can now finish the task since I have the information needed to identify a user with the same profession.', 'tool_name_1': 'finish', 'tool_args_1': {}, 'observation_1': 'Completed.'},\n    reasoning='I identified a user who shares the same profession as a software engineer. The user is Jane Doe, who is explicitly described as a software engineer. This matches the criteria I was looking for.',\n    response='The user who is a software engineer like you is Jane Doe.'\n)\n</code></pre> Lets test out the emailing functionality. <pre><code>response = agent(\n    question=\"Can you email a designer in my network? I need someone to design the UI for my website.\"\n)\nprint(response)\n</code></pre></p> <p>Response: <pre><code>Prediction(\n    trajectory={'thought_0': \"I need to find a designer in the user's network before I can email them. I will use the get_user_profiles tool to retrieve user profiles that might include designers.\", 'tool_name_0': 'get_user_profiles', 'tool_args_0': {'description': 'designer'}, 'observation_0': [UserProfile(name='John Doe', age=30, description='John is a designer', email='john.doe@example.com'), UserProfile(name='Jane Doe', age=25, description='Jane is a software engineer', email='jane.doe@example.com')], 'thought_1': \"I found a designer named John Doe in the user's network. I will proceed to email him regarding the UI design for the website.\", 'tool_name_1': 'email_user', 'tool_args_1': {'email': 'john.doe@example.com', 'message': \"Hi John, I hope you're doing well! I need someone to design the UI for my website and I thought of you. Would you be interested in discussing this project further?\"}, 'observation_1': \"Email sent to john.doe@example.com with message: Hi John, I hope you're doing well! I need someone to design the UI for my website and I thought of you. Would you be interested in discussing this project further?\", 'thought_2': 'I have successfully emailed John Doe about the UI design for the website. Since the task is complete, I will finish the process.', 'tool_name_2': 'finish', 'tool_args_2': {}, 'observation_2': 'Completed.'},\n    reasoning=\"I identified a designer named John Doe in the user's network and successfully emailed him regarding the UI design for the website. The email was sent with a clear message expressing the user's need for a designer and inviting John to discuss the project further.\",\n    response='I have emailed John Doe about the UI design for your website. He should get back to you soon.'\n) \n</code></pre></p> <p>Push to the hub (optional) <pre><code>agent.push_to_hub(\"modaic/networking-agent\")\n</code></pre></p>"},{"location":"blog/","title":"Blog","text":""},{"location":"guides/context_engineering/","title":"Context Engineering with Modaic","text":"<p>Modaic comes with a powerful context engineering toolkit that is designed to be extremely flexible while still being portable and easy to use. In our SDK you have a range of context types to choose from and you can also easily define your own context class with custom behavior. From simple context classes like text and images to more complex context classes like tables, code bases, and user profiles.</p>"},{"location":"guides/context_engineering/#molecular-and-atomic-context","title":"Molecular and Atomic Context","text":"<p>Wait... why are we talking about chemistry? Good question. In Modaic we split context into two parts. Molecular and Atomic. <code>Atomic</code> context, as the name suggests, is atomic. It cannot be broken down into further parts. Some examples include text, a single image, or a single website element. <code>Molecular</code> context is a context which can be chunked into smaller parts of either <code>Atomic</code> or <code>Molecular</code> context. Like a markdown doc, a pdf, or a website. When you create a custom context class you will extend from one of these two base classes.</p>"},{"location":"guides/context_engineering/#contextschema","title":"ContextSchema","text":"<p>The <code>ContextSchema</code> class helps define how our context objects will be serialized and deserialized when they are stored in vector and graph databases. Every context class must define a class attribute called <code>schema</code> which points to its to a child class of <code>ContextSchema</code> and defines what fields from your context class will be serialized and how. <code>ContextSchema</code> under the hood is a <code>pydantic.BaseModel</code> so you can use all the features of pydantic to define your serialized context class.</p>"},{"location":"guides/context_engineering/#source-tracking","title":"Source Tracking","text":"<p>All context classes automatically track their source. Throughout your entire framework. The <code>Source</code> class is a <code>pydantic.BaseModel</code> that contains the following fields: <pre><code>class SourceType(str, Enum):\n    LOCAL_PATH = \"local_path\" # The context is a local file path\n    URL = \"url\" # The context is a url\n    SQL_DB = \"sql_db\" # The context is a SQL database\n\nclass Source(BaseModel):\n    origin: Optional[str] = None #The filename, url, or hostname the context originates from\n    type: Optional[SourceType] = None # The type of origin. See `SourceType` above\n    metadata: dict = {} # Source metadata that can be used to identify the context in the origin. For example, a chunk id, row id, or table id.\n    parent: Optional[Context] = None # A special property that is not serialized but contains a weakref to the context's parent context. \n</code></pre></p> <p>Warning</p> <p><code>parent</code> is a weakref to the parent context object. When the parent context goes out of scope, <code>source.parent</code> will be <code>None</code>. Also, <code>parent</code> is never serialized.</p>"},{"location":"guides/context_engineering/#methods","title":"Methods","text":""},{"location":"guides/context_engineering/#predefined-methods","title":"Predefined Methods","text":"<p>All <code>Context</code> classes come with 2 main methods: <pre><code>def serialize(self) -&gt; ContextSchema:\n    \"\"\"Serialize the context into a `ContextSchema` object.\"\"\"\n</code></pre> <pre><code>@classmethod\ndef deserialize(cls, serialized: ContextSchema | dict, **kwargs) -&gt; Context:\n    \"\"\"Deserialize the context from a `ContextSchema` object. Can use kwargs to pass in additional fields to the Context constructor. \n    For example, fields that were not serialized but are needed to initialize the context. Or fields that you would like to override from the serialized context.\"\"\"\n</code></pre> <pre><code>    def readme(self) -&gt; str | BaseModel:\n        \"\"\"\n        By defualt returns self.serialized_schema, however, you can override this method to return a custom readme string or pydantic BaseModel.\n        Returns:\n            The readme string or pydantic BaseModel that should be read by LLMs.\n        \"\"\"\n</code></pre></p> <p>Additionally, the context classes that extend from <code>Molecular</code> have a <code>chunk_with</code> method that can be used to chunk the context into smaller parts. It has the following signature:</p> <pre><code>def chunk_with(self, chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs) -&gt; bool:\n    \"\"\"\n     Chunks a Molecular context into smaller parts of either `Atomic` or `Molecular` context. Chunks will be stored in the `.chunks` attribute.\n     Args:\n     - chunk_fn: A function that takes a context and returns a list of context objects.\n     - set_source: Whether to automatically set the source of the chunked context objects based on the parent context.\n     - **kwargs: Additional keyword arguments to pass to the chunk function.\n    \"\"\"\n</code></pre> <p>Tip</p> <p>All the above methods are automatically implemented for you when you extend from <code>Atomic</code> or <code>Molecular</code>. No need to override them. Unless you want to of course :wink:  </p>"},{"location":"guides/context_engineering/#abstract-methods","title":"Abstract Methods","text":"<p>The below methods are abstract methods that you must override when you extend from <code>Atomic</code> or <code>Molecular</code>.</p> <pre><code>    @abstractmethod\n    def embedme(self) -&gt; str | PIL.Image.Image:\n        \"\"\"\n        Abstract method defined by all subclasses of `Context` to define embedding behavior for embedding models.\n        Returns:\n            The string or image that should be used to embed the context.\n        \"\"\"\n</code></pre>"},{"location":"guides/context_engineering/#storage","title":"Storage","text":""},{"location":"guides/custom_context/","title":"Create A Custom Context Class","text":"<p>In this guide we will show you how to create your own context class. The context engineering toolkit in Modaic is extremely powerful and flexible. To learn more about how it works, check out the context engineering guide. In this guide we will show you how to create a custom user profile and organization profile context class for a social networking agent.</p>"},{"location":"guides/custom_context/#the-userprofile-class","title":"The UserProfile class","text":"<p>First we will define the <code>UserProfile</code> class as well as its <code>UserProfileSchema</code> class. <pre><code>from modaic.context import Atomic, Molecular, ContextSchema\nimport requests\nfrom PIL import Image\nfrom io import BytesIO\n\n# First we define UserProfile's ContextSchema class.\n# As you can see below, only name, age, email,and description will be serialized. profile_pic will be loaded during construction.\nclass UserProfileSchema(ContextSchema):\n    name: str\n    age: int\n    description: str\n    email: str\n\nclass UserProfile(Atomic):\n    serialized_schema = UserProfileSchema # !!! Super important for serialization and deserialization.\n    def __init__(self, name: str, age: int, description: str, email: str, profile_pic: PIL.Image.Image, **kwargs):\n        # All attibutes that will be serialized must match fields of UserProfileSchema\n        super().__init__(**kwargs) # !!! Important. Allows the parent class to initalize source and metadata.\n        self.name = name \n        self.age = age\n        self.description = description\n        self.email = email\n        self.profile_pic = self.get_profile_pic()\n\n    def get_profile_pic(self) -&gt; PIL.Image.Image:\n        response = requests.get(self.source.origin)\n        data = response.json()\n        img_response = requests.get(data[\"profile_pic\"])\n        return Image.open(BytesIO(img_response.content))\n\n    # Define the abstract method embedme\n    def embedme(self) -&gt; str:\n        return self.description\n\n    # Define the readme method.\n    # We don't explicitly need to do this since by default the readme method will return self.serialize()\n    # However, its useful to override when you need custom behavior.\n    def readme(self) -&gt; str:\n        return f\"\"\"\n        User Name: {self.name}\n        Age: {self.age}\n        Email: {self.email}\n        Description: {self.description}\n        \"\"\"\n</code></pre> So what did we do here? </p> <ol> <li> <p>We defined the <code>UserProfile</code> class that extends from the <code>Atomic</code> context type. It has the attributes <code>name</code>, <code>age</code>, <code>description</code>, <code>email</code>, and <code>profile_pic</code>. Profile pic is dynamically loaded from the backend.</p> </li> <li> <p>We defined the <code>UserProfileSchema</code> which determines serialization behavior for the <code>UserProfile</code> class. It expects the attributes <code>name</code>, <code>age</code>, <code>description</code>, and <code>email</code>. It will ignore the <code>profile_pic</code> attribute.</p> </li> <li> <p>We implemented the <code>embedme</code> method which returns the <code>description</code> of the user.</p> </li> <li> <p>We implemented the <code>readme</code> method which returns a string that represents the user profile.</p> </li> </ol> <p>Let's see what this looks like in action!</p> <p><pre><code>from modaic.databases import VectorDatabase, MilvusVDBConfig\nfrom modaic.utils import Embedder\nfrom modaic.context import Source, SourceType\nimport dspy\n\nmilvus_config = MilvusVDBConfig.from_local(file_path=\"index.db\")\nvector_db = VectorDatabase(\n    config=milvus_config,\n    embedder=Embedder(model=\"openai/text-embedding-3-small\"),\n)\n\nuser_profile1 = UserProfile(\n    name=\"John Doe\",\n    age=30,\n    description=\"John Doe is a software engineer at Google. He also loves dogs.\",\n    email=\"john.doe@gmail.com\",\n    source=Source(origin=\"https://example.com/john_doe\", type=SourceType.URL),\n)\nuser_profile2 = UserProfile(\n    name=\"Jane Smith\",\n    age=25,\n    description=\"Jane Smith is a software engineer at Meta.\",\n    email=\"jane.smith@gmail.com\",\n    source=Source(origin=\"https://example.com/jane_smith\", type=SourceType.URL),\n)\nvector_db.create_collection(\"user_profiles\", payload_schema=UserProfileSchema)\n\n# Add records to the vector database. The `add_records` method will automatically call the `.embedme()` function and pass the result into the Embedder to embed the context.\nvector_db.add_records(\n    \"user_profiles\",\n    [user_profile1, user_profile2],\n)\n\n# Now lets search for user profiles.\nmeta_employee = vector_db.search(\n    \"user_profiles\",\n    \"Someone who works at Meta\",\n    k=1,\n)\n# This should *hopefully* return Jane Smith.\n\n# Now lets have an give us a summary of the meta employee.\n\nsummarizer = dspy.Predict(\"user_profile -&gt; summary\")\nsummarizer.set_lm(dspy.LM(model=\"openai/gpt-4o-mini\"))\n\nsummary = summarizer(user_profile=meta_employee.readme())\n</code></pre> What happened here?</p> <ol> <li> <p>We created two user profiles and added them to the vector database. The vector database automatically used <code>description</code> to embed the context. Since that is what <code>embedme()</code> returns</p> </li> <li> <p>We fetched the <code>meta_employee</code> context from the vector database, then summarized the profile by feeding in the result of the <code>readme</code> method to a dspy.Predict module. (just a simple LLM call)</p> </li> </ol>"},{"location":"guides/custom_context/#alternate-implementation","title":"Alternate Implementation","text":"<p>What if instead we wanted to embed users based on what they look like? All we would have to do is change the <code>embedme</code> method to return the profile picture.</p> <pre><code>def embedme(self) -&gt; PIL.Image.Image:\n    return self.profile_pic\n</code></pre>"},{"location":"guides/custom_context/#the-organizationprofile-class","title":"The OrganizationProfile class","text":"<p>Now that we have a <code>UserProfile</code> class, we can create an <code>OrganizationProfile</code> class. That is composed of multiple <code>UserProfile</code>s. Since UserProfile can be chunked, it is a good idea to make it extend the <code>Molecular</code> context type.</p> <pre><code>from modaic.context import Molecular\nimport requests\n\nclass OrganizationProfileSchema(ContextSchema):\n    name: str\n    website_url: str\n\nclass OrganizationProfile(Molecular):\n    def __init__(self, name: str, website_url: str, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.website_url = website_url\n    # We won't define a proper embedme since we aren't going to be embedding organization profiles.\n    def embedme(self) -&gt; str: \n        pass\n\n    def readme(self) -&gt; str:\n        return f\"\"\"\n        Organization Name: {self.name}\n        Description: {self.description}\n        \"\"\"\n\n    # We will also define a method that fetches an organization profile from a url.\n    @staticmethod\n    def from_url(url: str) -&gt; OrganizationProfile:\n        org = requests.get(url).json().data\n        return OrganizationProfile(**org)\n\ndef chunk_by_user(org_profile: OrganizationProfile) -&gt; list[UserProfile]:\n    users = requests.get(f'{org_profile.source.origin}/users').json().data\n    return [UserProfile(**user) for user in users]\n\n# Now lets create an organization profile.\norg_profile1 = OrganizationProfile(\n    name=\"Google\",\n    description=\"Google is a search engine company.\",\n    source=Source(origin=\"https://api.example.com/google\", type=SourceType.URL),\n)\norg_profile2 = OrganizationProfile(\n    name=\"Meta\",\n    description=\"Meta is a social networking company.\",\n    source=Source(origin=\"https://api.example.com/meta\", type=SourceType.URL),\n)\n\nvector_db.create_collection(\"user_profiles\", payload_schema=OrganizationProfileSchema)\n\norg_profile1.chunk_with(chunk_fn=chunk_by_user)\norg_profile2.chunk_with(chunk_fn=chunk_by_user)\n\nvector_db.add_records(\n    \"user_profiles\",\n    org_profile1.chunks + org_profile2.chunks,\n)\n\n# Now lets search for user profiles.\ndog_lover = vector_db.search(\n    \"user_profiles\",\n    \"Someone who loves dogs\",\n    k=1,\n)\n\n# We can use the source attribute to get the organization this profile belongs to.\norg_url = dog_lover.source.origin\norg_profile = OrganizationProfile.from_url(org_url)\n</code></pre>"},{"location":"guides/custom_context/#advanced-usage-grabbing-values-at-serialization-time","title":"Advanced Usage: Grabbing values at serialization time","text":"<p>Lets say we want to add a last accessed timestamp to out user profile for filtering in the vector database. <pre><code>import datetime\n\nclass UserProfileSchema(ContextSchema):\n    name: str\n    age: int\n    description: str\n    email: str\n    last_accessed: str\n\nclass UserProfile(Molecular):\n    def __init__(self, name: str, age: int, description: str, email: str, last_accessed: datetime.datetime, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.age = age\n        self.description = description\n        self.email = email\n        self.last_accessed = datetime.datetime.now().isoformat()\n</code></pre> We have a problem! <code>last_accessed</code> will refer to the time of constructution, not of serialization. The solution? We can actually add the output of functions to <code>UserProfileSchema</code> as long as they can be called with no arguments. <pre><code>class UserProfileSchema(ContextSchema):\n    name: str\n    age: int\n    description: str\n    email: str\n    last_accessed: str\n\nclass UserProfile(Molecular):\n    def __init__(self, name: str, age: int, description: str, email: str, last_accessed: datetime.datetime, **kwargs):\n        super().__init__(**kwargs)\n        self.name = name\n        self.age = age\n        self.description = description\n        self.email = email\n\n    def last_accessed(self) -&gt; str:\n        return datetime.datetime.now().isoformat()\n</code></pre></p> <p>the <code>serialize</code> funtion will automatically look for a function named <code>last_accessed</code> and call it to get the value of <code>last_accessed</code> during serialization.</p>"},{"location":"reference/precompiled_agent/","title":"PrecompiledAgent","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent","title":"<code>modaic.precompiled_agent.PrecompiledAgent</code>","text":"<p>Bases: <code>dspy.Module</code></p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.forward","title":"<code>forward(**kwargs) -&gt; str</code>","text":"<p>Forward pass for the agent.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Forward pass result.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the agent and the config to the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the agent and config to. Must be a local path.</p> required"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.from_precompiled","title":"<code>from_precompiled(path: str, **kwargs) -&gt; PrecompiledAgent</code>  <code>classmethod</code>","text":"<p>Loads the agent and the config from the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the agent and config from. Can be a local path or a path on Modaic Hub.</p> required <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>PrecompiledAgent</code> <p>An instance of the PrecompiledAgent class.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledAgent.push_to_hub","title":"<code>push_to_hub(repo_id: str) -&gt; None</code>","text":"<p>Pushes the agent and the config to the given repo_id.</p> <p>Parameters:</p> Name Type Description Default <code>repo_id</code> <code>str</code> <p>The path on Modaic hub to save the agent and config to.</p> required"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig","title":"<code>modaic.precompiled_agent.PrecompiledConfig</code>","text":""},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.save_precompiled","title":"<code>save_precompiled(path: str) -&gt; None</code>","text":"<p>Saves the config to a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to save the config to.</p> required"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_precompiled","title":"<code>from_precompiled(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a config.json file in the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_dict","title":"<code>from_dict(dict: Dict) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <code>Dict</code> <p>A dictionary containing the config.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p>"},{"location":"reference/precompiled_agent/#modaic.precompiled_agent.PrecompiledConfig.from_json","title":"<code>from_json(path: str) -&gt; PrecompiledConfig</code>  <code>classmethod</code>","text":"<p>Loads the config from a json file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load the config from.</p> required <p>Returns:</p> Type Description <code>PrecompiledConfig</code> <p>An instance of the PrecompiledConfig class.</p>"},{"location":"reference/context/context/","title":"Context","text":""},{"location":"reference/context/context/#modaic.context.Context","title":"<code>modaic.context.Context</code>","text":""},{"location":"reference/context/context/#modaic.context.Context.__init__","title":"<code>__init__(source: Optional[Source] = None, metadata: Optional[dict] = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>source</code> <code>Optional[Source]</code> <p>The source of the context.</p> <code>None</code> <code>metadata</code> <code>Optional[dict]</code> <p>The metadata of the context. If None, an empty dict is created</p> <code>None</code>"},{"location":"reference/context/context/#modaic.context.Context.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/context/#modaic.context.Context.readme","title":"<code>readme() -&gt; str | pydantic.BaseModel</code>","text":"<p>How LLMs should read the context. By default returns self.serialize()</p> <p>Returns:</p> Type Description <code>str | BaseModel</code> <p>LLM readable format of the context.</p>"},{"location":"reference/context/context/#modaic.context.Context.serialize","title":"<code>serialize() -&gt; ContextSchema</code>","text":"<p>Serializes the context object into its associated <code>ContextSchema</code> object. Defined at self.schema.</p> <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Context.deserialize","title":"<code>deserialize(serialized: ContextSchema | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>ContextSchema</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>ContextSchema | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the ContextSchema object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Context.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Context.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Context.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/context/#modaic.context.Context.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic","title":"<code>modaic.context.Atomic</code>","text":"<p>Base class for all Atomic Context objects. Atomic objects represent context at its finest granularity and are not chunkable.</p> Example <p>In this example, <code>CaptionedImage</code> is an <code>Atomic</code> context object that stores the caption and the caption embedding. <pre><code>from modaic.context import ContextSchema\nfrom modaic.types import String, Vector, Float16Vector\n\nclass CaptionImageSchema(ContextSchema):\n    caption: String[100]\n    caption_embedding: Float16Vector[384]\n    image_path: String[100]\n\nclass CaptionedImage(Atomic):\n    schema = CaptionImageSchema\n\n    def __init__(self, image_path: str, caption: str, caption_embedding: np.ndarray, **kwargs):\n        super().__init__(**kwargs)\n        self.caption = caption\n        self.caption_embedding = caption_embedding\n        self.image_path = image_path\n        self.image = PIL.Image.open(image_path)\n\n    def embedme(self) -&gt; PIL.Image.Image:\n        return self.image\n</code></pre></p>"},{"location":"reference/context/context/#modaic.context.Atomic.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.readme","title":"<code>readme() -&gt; str | pydantic.BaseModel</code>","text":"<p>How LLMs should read the context. By default returns self.serialize()</p> <p>Returns:</p> Type Description <code>str | BaseModel</code> <p>LLM readable format of the context.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.serialize","title":"<code>serialize() -&gt; ContextSchema</code>","text":"<p>Serializes the context object into its associated <code>ContextSchema</code> object. Defined at self.schema.</p> <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.deserialize","title":"<code>deserialize(serialized: ContextSchema | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>ContextSchema</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>ContextSchema | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the ContextSchema object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Atomic.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Atomic.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/context/#modaic.context.Atomic.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular","title":"<code>modaic.context.Molecular</code>","text":"<p>Base class for all <code>Molecular</code> Context objects. <code>Molecular</code> context objects represent context that can be chunked into smaller <code>Molecular</code> or <code>Atomic</code> context objects.</p> Example <p>In this example, <code>MarkdownDoc</code> is a <code>Molecular</code> context object that stores a markdown document. <pre><code>from modaic.context import Molecular\nfrom modaic.types import String, Vector, Float16Vector\nfrom langchain_text_splitters import MarkdownTextSplitter\nfrom modaic.context import Text\n\nclass MarkdownDocSchema(ContextSchema):\n    markdown: String\n\nclass MarkdownDoc(Molecular):\n    schema = MarkdownDocSchema\n\n    def chunk(self):\n        # Split the markdown into chunks of 1000 characters\n        splitter = MarkdownTextSplitter()\n        chunk_fn = lambda mdoc: [Text(text=t) for t in splitter.split_text(mdoc.markdown)]\n        self.chunk_with(chunk_fn)\n\n    def __init__(self, markdown: str, **kwargs):\n        super().__init__(**kwargs)\n        self.markdown = markdown\n</code></pre></p>"},{"location":"reference/context/context/#modaic.context.Molecular.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.readme","title":"<code>readme() -&gt; str | pydantic.BaseModel</code>","text":"<p>How LLMs should read the context. By default returns self.serialize()</p> <p>Returns:</p> Type Description <code>str | BaseModel</code> <p>LLM readable format of the context.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.serialize","title":"<code>serialize() -&gt; ContextSchema</code>","text":"<p>Serializes the context object into its associated <code>ContextSchema</code> object. Defined at self.schema.</p> <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.deserialize","title":"<code>deserialize(serialized: ContextSchema | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>ContextSchema</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>ContextSchema | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the ContextSchema object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Molecular.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/context/#modaic.context.Molecular.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/context/#modaic.context.Molecular.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/context/#modaic.context.Molecular.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/context/serialized_context/","title":"ContextSchema","text":""},{"location":"reference/context/serialized_context/#modaic.context.ContextSchema","title":"<code>modaic.context.ContextSchema</code>","text":"<p>Base class used to define the schema of a context object when they are serialized.</p> <p>Attributes:</p> Name Type Description <code>context_class</code> <code>str</code> <p>The class of the context object that this serialized context is for.</p> <code>id</code> <code>str</code> <p>The id of the serialized context.</p> <code>source</code> <code>Source</code> <p>The source of the context object.</p> <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> Example <p>In this example, <code>CaptionedImageSchema</code> stores the caption and the caption embedding while <code>CaptionedImage</code> is the <code>Context</code> class that is used to store the context object. Note that the image is loaded dynamically in the <code>CaptionedImage</code> class and is not serialized to <code>CaptionedImageSchema</code>. <pre><code>from modaic.context import ContextSchema\nfrom modaic.types import String, Vector, Float16Vector\n\nclass CaptionedImageSchema(ContextSchema):\n    caption: String[100]\n    caption_embedding: Float16Vector[384]\n    image_path: String[100]\n\nclass CaptionedImage(Atomic):\n    schema = CaptionedImageSchema\n\n    def __init__(self, image_path: str, caption: str, caption_embedding: np.ndarray, **kwargs):\n        super().__init__(**kwargs)\n        self.caption = caption\n        self.caption_embedding = caption_embedding\n        self.image_path = image_path\n        self.image = PIL.Image.open(image_path)\n\n    def embedme(self) -&gt; PIL.Image.Image:\n        return self.image\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types","title":"<code>modaic.types</code>","text":""},{"location":"reference/context/serialized_context/#modaic.types.Array","title":"<code>Array</code>","text":"<p>Array field type for <code>ContextSchema</code>. Must be created with Array[dtype, max_size]</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>Type</code> <p>The type of the elements in the array.</p> required <code>max_size</code> <code>int</code> <p>The maximum size of the array.</p> required Example <p>A <code>EmailSchema</code> for <code>Email</code> context class that stores an email's content and recipients. <pre><code>from modaic.types import Array\nfrom modaic.context import ContextSchema\n\nclass EmailSchema(ContextSchema):\n    content: str\n    recipients: Array[str, 100]\n</code></pre></p>"},{"location":"reference/context/serialized_context/#modaic.types.String","title":"<code>String</code>","text":"<p>String type that can be parameterized with max_length constraint.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>The maximum length of the string.</p> required Example <pre><code>from modaic.types import String\nfrom modaic.context import ContextSchema\n\nclass EmailSchema(ContextSchema):\n    subject: String[100]\n    content: str\n    recipients: Array[str, 100]\n</code></pre>"},{"location":"reference/context/serialized_context/#modaic.types.unpack_type","title":"<code>unpack_type(field_type: Type) -&gt; SchemaField</code>","text":"<p>Unpacks a type into a compatible modaic schema field. Modaic schema fields can be any of the following for type: - Array - Vector, Float16Vector, Float32Vector, Float64Vector, BFloat16Vector, BinaryVector - String - int8, int16, int32, int64, float32, float64, double(float64), bool, float(float64), int(int64)</p> <p>The function will return a SchemaField dataclass with the following fields:</p> SchemaField - a dataclass with the following fields <p>optional (bool): Whether the field is optional. type (Type): The type of the field. size (int | None): The size of the field. inner_type (InnerField | None): The inner type of the field.</p> InnerField - a dataclass with the following fields <p>type (Type): The type of the inner field. size (int | None): The size of the inner field.</p> <p>Parameters:</p> Name Type Description Default <code>field_type</code> <code>Type</code> <p>The type to unpack.</p> required <p>Returns:</p> Type Description <code>SchemaField</code> <p>SchemaField - a dataclass containing information to serialize the type.</p>"},{"location":"reference/context/serialized_context/#modaic.types.pydantic_to_modaic_schema","title":"<code>pydantic_to_modaic_schema(pydantic_model: Type[BaseModel]) -&gt; Dict[str, SchemaField]</code>","text":"<p>Unpacks a type into a dictionary of compatible modaic schema fields. Modaic schema fields can be any of the following for type: - Array - Vector, Float16Vector, Float32Vector, Float64Vector, BFloat16Vector, BinaryVector - String - int8, int16, int32, int64, float32, float64, double(float64), bool, float(float64), int(int64)</p> <p>The function will return a dictionary mapping field names to SchemaField dataclasses.</p> SchemaField - a dataclass with the following fields <p>optional (bool): Whether the field is optional. type (Type): The type of the field. size (int | None): The size of the field. inner_type (InnerField | None): The inner type of the field.</p> InnerField is a dataclass with the following fields <p>type (Type): The type of the inner field. size (int | None): The size of the inner field.</p> <p>Parameters:</p> Name Type Description Default <code>pydantic_model</code> <code>Type[BaseModel]</code> <p>The pydantic model to unpack.</p> required <p>Returns:</p> Name Type Description <code>schema</code> <code>Dict[str, SchemaField]</code> <p>A dictionary mapping field names to SchemaField dataclasses.</p>"},{"location":"reference/context/table/","title":"Table","text":"<p>handler: python</p> <p>handler: python</p>"},{"location":"reference/context/table/#modaic.context.table.Table","title":"<code>modaic.context.table.Table</code>","text":"<p>A molecular context object that represents a table. Can be queried with SQL.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.__init__","title":"<code>__init__(df: pd.DataFrame, name: str, prepare_for_sql: bool = True, **kwargs)</code>","text":"<p>Initializes a Table context object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to represent as a table.</p> required <code>name</code> <code>str</code> <p>The name of the table.</p> required <code>prepare_for_sql</code> <code>bool</code> <p>Whether to prepare the table for SQL queries.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the Molecular context object.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.Table.get_col","title":"<code>get_col(col_name: str) -&gt; pd.Series</code>","text":"<p>Gets a single column from the table.</p> <p>Parameters:</p> Name Type Description Default <code>col_name</code> <code>str</code> <p>Name of the column to get</p> required <p>Returns:</p> Type Description <code>Series</code> <p>The specified column as a pandas Series.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.get_schema_with_samples","title":"<code>get_schema_with_samples()</code>","text":"<p>Returns a dictionary of mapping column names to dictionaries containing the column type and sample values.</p> Example <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]})\n&gt;&gt;&gt; table = Table(df, name=\"table\")\n&gt;&gt;&gt; table.get_schema_with_samples()\n{\"Column1\": {\"type\": \"INT\", \"sample_values\": [1, 2, 3]}, \"Column2\": {\"type\": \"INT\", \"sample_values\": [4, 5, 6]}, \"Column3\": {\"type\": \"INT\", \"sample_values\": [7, 8, 9]}}\n</code></pre>"},{"location":"reference/context/table/#modaic.context.table.Table.query","title":"<code>query(query: str)</code>","text":"<p>Queries the table. All queries run should refer to the table as <code>this</code> or <code>This</code></p>"},{"location":"reference/context/table/#modaic.context.table.Table.markdown","title":"<code>markdown() -&gt; str</code>","text":"<p>Converts the table to markdown format. Returns a markdown representation of the table with the table name as header.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.readme","title":"<code>readme()</code>","text":"<pre><code>    readme method for table. Returns a markdown representation of the table.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; df = pd.DataFrame({\"Column1\": [1, 2, 3], \"Column2\": [4, 5, 6], \"Column3\": [7, 8, 9]})\n        &gt;&gt;&gt; table = Table(df, name=\"table\")\n        &gt;&gt;&gt; table.readme()\n        \"Table name: table\n</code></pre> <p>\"             \" | Column1 | Column2 | Column3 |  \"             \" | --- | --- | --- |  \"             \" | 1 | 2 | 3 |  \"             \" | 4 | 5 | 6 |  \"             \" | 7 | 8 | 9 |  \"             ```</p>"},{"location":"reference/context/table/#modaic.context.table.Table.embedme","title":"<code>embedme()</code>","text":"<p>embedme method for table. Returns a markdown representation of the table.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.serialize","title":"<code>serialize() -&gt; ContextSchema</code>","text":"<p>Serializes the context object into its associated <code>ContextSchema</code> object. Defined at self.schema.</p> <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.deserialize","title":"<code>deserialize(serialized: ContextSchema | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>ContextSchema</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>ContextSchema | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the ContextSchema object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.Table.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.Table.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.Table.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.Table.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable","title":"<code>modaic.context.table.MultiTabbedTable</code>","text":""},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.init_sql","title":"<code>init_sql()</code>","text":"<p>Initilizes and in memory sql database for querying</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.close_sql","title":"<code>close_sql()</code>","text":"<p>Closes the in memory sql database</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.query","title":"<code>query(query: str)</code>","text":"<p>Queries the in memory sql database</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.embedme","title":"<code>embedme() -&gt; str | PIL.Image.Image</code>  <code>abstractmethod</code>","text":"<p>Abstract method defined by all subclasses of <code>Context</code> to define how embedding modeles should embed the context.</p> <p>Returns:</p> Type Description <code>str | Image</code> <p>The string or image that should be used to embed the context.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.readme","title":"<code>readme() -&gt; str | pydantic.BaseModel</code>","text":"<p>How LLMs should read the context. By default returns self.serialize()</p> <p>Returns:</p> Type Description <code>str | BaseModel</code> <p>LLM readable format of the context.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.serialize","title":"<code>serialize() -&gt; ContextSchema</code>","text":"<p>Serializes the context object into its associated <code>ContextSchema</code> object. Defined at self.schema.</p> <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.deserialize","title":"<code>deserialize(serialized: ContextSchema | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>ContextSchema</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>ContextSchema | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the ContextSchema object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/table/#modaic.context.table.MultiTabbedTable.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/context/text/","title":"Text","text":"<p>handler: python</p> <p>handler: python</p>"},{"location":"reference/context/text/#modaic.context.text.Text","title":"<code>modaic.context.text.Text</code>","text":""},{"location":"reference/context/text/#modaic.context.text.Text.serialize","title":"<code>serialize() -&gt; ContextSchema</code>","text":"<p>Serializes the context object into its associated <code>ContextSchema</code> object. Defined at self.schema.</p> <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.Text.deserialize","title":"<code>deserialize(serialized: ContextSchema | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>ContextSchema</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>ContextSchema | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the ContextSchema object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.Text.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.Text.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.Text.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/text/#modaic.context.text.Text.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText","title":"<code>modaic.context.text.LongText</code>","text":""},{"location":"reference/context/text/#modaic.context.text.LongText.chunk_text","title":"<code>chunk_text(chunk_fn: Callable[[str], List[str | tuple[str, dict]]]) -&gt; List[Text]</code>","text":"<p>Chunk the text into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>Callable[[str], List[str | tuple[str, dict]]]</code> <p>A function that takes in a string and returns a list of strings or string-metadata pairs.</p> required <p>Returns:</p> Type Description <code>List[Text]</code> <p>A list of Context objects.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.serialize","title":"<code>serialize() -&gt; ContextSchema</code>","text":"<p>Serializes the context object into its associated <code>ContextSchema</code> object. Defined at self.schema.</p> <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.deserialize","title":"<code>deserialize(serialized: ContextSchema | dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a <code>ContextSchema</code> object into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>ContextSchema | dict</code> <p>The serialized context object or a dict.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the ContextSchema object)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.set_source","title":"<code>set_source(source: Source, copy: bool = False)</code>","text":"<p>Sets the source of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Source</code> <p>Source - The source of the context object.</p> required <code>copy</code> <code>bool</code> <p>bool - Whether to copy the source object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.LongText.set_metadata","title":"<code>set_metadata(metadata: dict, copy: bool = False)</code>","text":"<p>Sets the metadata of the context object.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>The metadata of the context object.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the metadata object to make it safe to mutate.</p> <code>False</code>"},{"location":"reference/context/text/#modaic.context.text.LongText.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Adds metadata to the context object. Args:     metadata: The metadata to add to the context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.from_dict","title":"<code>from_dict(d: dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Deserializes a dict into a <code>Context</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dict to deserialize.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to the Context object's constructor. (will overide any attributes set in the dict)</p> <code>{}</code> <p>Returns:</p> Type Description <p>The deserialized context object.</p>"},{"location":"reference/context/text/#modaic.context.text.LongText.chunk_with","title":"<code>chunk_with(chunk_fn: str | Callable[[Context], List[Context]], set_source: bool = True, **kwargs)</code>","text":"<p>Chunk the context object into smaller Context objects.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_fn</code> <code>str | Callable[[Context], List[Context]]</code> <p>The function to use to chunk the context object. The function should take in a specific type of Context object and return a list of Context objects.</p> required <code>set_source</code> <code>bool</code> <p>bool - Whether to automatically set the source of the chunks using the Context object. (sets chunk.source to self.source, sets chunk.source.parent to self, and updates the chunk.source.metadata with the chunk_id)</p> <code>True</code> <code>**kwargs</code> <p>dict - Additional keyword arguments to pass to the chunking function.</p> <code>{}</code>"},{"location":"reference/context/text/#modaic.context.text.LongText.apply_to_chunks","title":"<code>apply_to_chunks(apply_fn: Callable[[Context], None], **kwargs)</code>","text":"<p>Applies apply_fn to each chunk in chunks.</p> <p>Parameters:</p> Name Type Description Default <code>apply_fn</code> <code>Callable[[Context], None]</code> <p>The function to apply to each chunk. Function should take in a Context object and mutate it.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to apply_fn.</p> <code>{}</code>"},{"location":"reference/databases/sql_database/","title":"SQL Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase","title":"<code>modaic.databases.sql_database.SQLDatabase</code>","text":""},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.drop_table","title":"<code>drop_table(name: str, must_exist: bool = False)</code>","text":"<p>Drop a table from the database and remove its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to drop</p> required"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.list_tables","title":"<code>list_tables()</code>","text":"<p>List all tables currently in the database.</p> <p>Returns:</p> Type Description <p>List of table names in the database.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_schema","title":"<code>get_table_schema(name: str)</code>","text":"<p>Return column schema for a given table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get schema for</p> required <p>Returns:</p> Type Description <p>Column schema information for the table.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.get_table_metadata","title":"<code>get_table_metadata(name: str) -&gt; dict</code>","text":"<p>Get metadata for a specific table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the table to get metadata for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing the table's metadata, or empty dict if not found.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.from_dir","title":"<code>from_dir(dir_path: str, config: SQLDatabaseConfig)</code>  <code>classmethod</code>","text":"<p>Initializes a new SQLDatabase from a directory of files.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>str</code> <p>Path to the directory containing files to load</p> required <code>config</code> <code>SQLDatabaseConfig</code> <p>SQL database configuration</p> required <p>Returns:</p> Type Description <p>New SQLDatabase instance loaded with data from the directory.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.connect","title":"<code>connect()</code>","text":"<p>Context manager for database connections. Reuses existing connection if available, otherwise creates a temporary one.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.open_persistent_connection","title":"<code>open_persistent_connection()</code>","text":"<p>Opens a persistent connection that will be reused across operations. Call close() to close the persistent connection.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.close","title":"<code>close()</code>","text":"<p>Closes the current connection if one exists.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.begin","title":"<code>begin()</code>","text":"<p>Context manager for database transactions using existing connection. Requires an active connection. Commits on success, rolls back on exception.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no active connection exists</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLDatabase.connect_and_begin","title":"<code>connect_and_begin()</code>","text":"<p>Context manager that establishes a connection and starts a transaction. Reuses existing connection if available, otherwise creates a temporary one. Commits on success, rolls back on exception.</p>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLServerConfig","title":"<code>modaic.databases.sql_database.SQLServerConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a SQL served over a port or remote connection. (MySQL, PostgreSQL, etc.)</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The username to connect to the database.</p> required <code>password</code> <code>str</code> <p>The password to connect to the database.</p> required <code>host</code> <code>str</code> <p>The host of the database.</p> required <code>database</code> <code>str</code> <p>The name of the database.</p> required <code>port</code> <code>Optional[str]</code> <p>The port of the database.</p> <code>None</code>"},{"location":"reference/databases/sql_database/#modaic.databases.sql_database.SQLiteConfig","title":"<code>modaic.databases.sql_database.SQLiteConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a SQLite database.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>Optional[str]</code> <p>Path to the SQLite database file.</p> <code>None</code> <code>in_memory</code> <code>bool</code> <p>Whether to create an in-memory SQLite database.</p> <code>False</code> <code>query_params</code> <code>Optional[dict]</code> <p>Query parameters to pass to the database.</p> <code>None</code>"},{"location":"reference/databases/vector_database/","title":"Vector Database","text":"<p>handler: python</p> <p>handler: python</p> <p>handler: python</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase","title":"<code>modaic.databases.vector_database.VectorDatabase</code>","text":""},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.__init__","title":"<code>__init__(config: VectorDatabaseConfig, embedder: Optional[Embedder] = None, payload_schema: Type[BaseModel] = None, **kwargs)</code>","text":"<p>Initialize a vanilla vector database. This is a base class for all vector databases. If you need more functionality from a specific vector database, you should use a specific subclass.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>VectorDatabaseConfig</code> <p>The configuration for the vector database</p> required <code>embedder</code> <code>Optional[Embedder]</code> <p>The embedder to use for the vector database</p> <code>None</code> <code>payload_schema</code> <code>Type[BaseModel]</code> <p>The Pydantic schema for validating context metadata</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.load_collection","title":"<code>load_collection(collection_name: str, payload_schema: Type[BaseModel], embedder: Optional[Embedder | Dict[str, Embedder]] = None)</code>","text":"<p>Load collection information into the vector database. Args:     collection_name: The name of the collection to load     payload_schema: The schema of the collection     index: The index configuration for the collection</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.create_collection","title":"<code>create_collection(collection_name: str, payload_schema: Type[BaseModel], index: IndexConfig | List[IndexConfig] = IndexConfig(), exists_behavior: Literal['fail', 'replace', 'append'] = 'replace')</code>","text":"<p>Create a collection in the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create</p> required <code>payload_schema</code> <code>Type[BaseModel]</code> <p>The schema of the collection</p> required <code>exists_behavior</code> <code>Literal['fail', 'replace', 'append']</code> <p>The behavior when the collection already exists</p> <code>'replace'</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.add_records","title":"<code>add_records(collection_name: str, records: Iterable[Context | Tuple[str, ContextSchema]], batch_size: Optional[int] = None)</code>","text":"<p>Add items to a collection in the vector database. Uses the Context's get_embed_context() method and the embedder to create embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to add records to</p> required <code>records</code> <code>Iterable[Context | Tuple[str, ContextSchema]]</code> <p>The records to add to the collection</p> required <code>batch_size</code> <code>Optional[int]</code> <p>Optional batch size for processing records</p> <code>None</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.search","title":"<code>search(collection_name: str, vector: np.ndarray | List[int], k: int = 10, filter: Optional[dict] = None, index_name: Optional[str] = None) -&gt; List[SearchResult]</code>","text":"<p>Retrieve records from the vector database. Returns a list of SearchResult dictionaries SearchResult is a TypedDict with the following keys: - id: The id of the record - distance: The distance of the record - context_schema: The serialized context of the record</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to search</p> required <code>vector</code> <code>ndarray | List[int]</code> <p>The vector to search with</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the search</p> <code>None</code> <p>Returns:</p> Name Type Description <code>results</code> <code>List[SearchResult]</code> <p>List of SearchResult dictionaries matching the search.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.get_record","title":"<code>get_record(collection_name: str, record_id: str) -&gt; ContextSchema</code>","text":"<p>Get a record from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection</p> required <code>record_id</code> <code>str</code> <p>The ID of the record to retrieve</p> required <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context record.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.hybrid_search","title":"<code>hybrid_search(collection_name: str, vectors: List[np.ndarray], index_names: List[str], k: int = 10) -&gt; List[ContextSchema]</code>","text":"<p>Hybrid search the vector database.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.query","title":"<code>query(query: str, k: int = 10, filter: Optional[dict] = None) -&gt; List[ContextSchema]</code>","text":"<p>Query the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the query</p> <code>None</code> <p>Returns:</p> Type Description <code>List[ContextSchema]</code> <p>List of serialized contexts matching the query.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabase.print_available_functions","title":"<code>print_available_functions(config_type: Type[VectorDatabaseConfig])</code>  <code>staticmethod</code>","text":"<p>Print the available functions for a given vector database configuration type.</p> <p>Parameters:</p> Name Type Description Default <code>config_type</code> <code>Type[VectorDatabaseConfig]</code> <p>The vector database configuration type to check</p> required"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.VectorDatabaseConfig","title":"<code>modaic.databases.vector_database.VectorDatabaseConfig</code>","text":"<p>Base class for vector database configurations. Each subclass must implement the <code>_module</code> class variable.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase","title":"<code>modaic.databases.vector_database.InMemoryVectorDatabase</code>","text":""},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.load_collection","title":"<code>load_collection(collection_name: str, payload_schema: Type[BaseModel], embedder: Optional[Embedder | Dict[str, Embedder]] = None)</code>","text":"<p>Load collection information into the vector database. Args:     collection_name: The name of the collection to load     payload_schema: The schema of the collection     index: The index configuration for the collection</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.create_collection","title":"<code>create_collection(collection_name: str, payload_schema: Type[BaseModel], index: IndexConfig | List[IndexConfig] = IndexConfig(), exists_behavior: Literal['fail', 'replace', 'append'] = 'replace')</code>","text":"<p>Create a collection in the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to create</p> required <code>payload_schema</code> <code>Type[BaseModel]</code> <p>The schema of the collection</p> required <code>exists_behavior</code> <code>Literal['fail', 'replace', 'append']</code> <p>The behavior when the collection already exists</p> <code>'replace'</code>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.search","title":"<code>search(collection_name: str, vector: np.ndarray | List[int], k: int = 10, filter: Optional[dict] = None, index_name: Optional[str] = None) -&gt; List[SearchResult]</code>","text":"<p>Retrieve records from the vector database. Returns a list of SearchResult dictionaries SearchResult is a TypedDict with the following keys: - id: The id of the record - distance: The distance of the record - context_schema: The serialized context of the record</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection to search</p> required <code>vector</code> <code>ndarray | List[int]</code> <p>The vector to search with</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the search</p> <code>None</code> <p>Returns:</p> Name Type Description <code>results</code> <code>List[SearchResult]</code> <p>List of SearchResult dictionaries matching the search.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.get_record","title":"<code>get_record(collection_name: str, record_id: str) -&gt; ContextSchema</code>","text":"<p>Get a record from the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>The name of the collection</p> required <code>record_id</code> <code>str</code> <p>The ID of the record to retrieve</p> required <p>Returns:</p> Type Description <code>ContextSchema</code> <p>The serialized context record.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.hybrid_search","title":"<code>hybrid_search(collection_name: str, vectors: List[np.ndarray], index_names: List[str], k: int = 10) -&gt; List[ContextSchema]</code>","text":"<p>Hybrid search the vector database.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.query","title":"<code>query(query: str, k: int = 10, filter: Optional[dict] = None) -&gt; List[ContextSchema]</code>","text":"<p>Query the vector database.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string</p> required <code>k</code> <code>int</code> <p>The number of results to return</p> <code>10</code> <code>filter</code> <code>Optional[dict]</code> <p>Optional filter to apply to the query</p> <code>None</code> <p>Returns:</p> Type Description <code>List[ContextSchema]</code> <p>List of serialized contexts matching the query.</p>"},{"location":"reference/databases/vector_database/#modaic.databases.vector_database.InMemoryVectorDatabase.print_available_functions","title":"<code>print_available_functions(config_type: Type[VectorDatabaseConfig])</code>  <code>staticmethod</code>","text":"<p>Print the available functions for a given vector database configuration type.</p> <p>Parameters:</p> Name Type Description Default <code>config_type</code> <code>Type[VectorDatabaseConfig]</code> <p>The vector database configuration type to check</p> required"}]}