---
title: Bases Classes
description: The Base Context Classes
---

## ModaicHydrationError

```python
class ModaicHydrationError(Exception)
```

Error raised when a function tries to use a Context param that is not hydrated.

#### HydratedAttr

```python
def HydratedAttr()
```

Created a hydrated field. Hydrated fields are fields that are None by default and are hydrated by Context.hydrate()

#### requires\_hydration

```python
def requires_hydration(func: t.Callable[..., t.Any]) -> t.Callable[..., t.Any]
```

Decorator that ensures all hydrated attributes are set before calling the function.

**Arguments**:

- `func` - The method being wrapped.
  

**Returns**:

  The wrapped method that raises if any hydrated attribute is None.

## ContextMeta

```python
class ContextMeta(ModelMetaclass)
```

#### \_\_getattr\_\_

```python
def __getattr__(cls, name: str) -> t.Any
```

Enablees the creation of Prop classes via ContextClass.property_name. Does this in a safe way that doesn't conflict with pydantic's own metaclass.

## Context

```python
class Context(BaseModel, metaclass=ContextMeta)
```

Base class for all Context objects.

**Attributes**:

- `id` - The id of the serialized context.
- `source` - The source of the context object.
- `metadata` - The metadata of the context object.
  

**Example**:

  In this example, `CaptionedImage` stores the caption and the caption embedding the image path and the image itself. Since we can't serialize the image, we use the `HydratedAttr` decorator to mark the `_image` field as requiring hydration.
    ```python
    from modaic.context import Context
    from modaic.types import String, Vector, Float16Vector

    class CaptionedImage(Context):
        caption: String[100]
        caption_embedding: Float16Vector[384]
        _image: PIL.Image.Image = HydratedAttr()

        def hydrate(self, file_store: FileStore):
            image_path = file_store.get_files(self.id)["image"]
            self._image = PIL.Image.open(image_path)

    ```

#### \_\_init\_subclass\_\_

```python
def __init_subclass__(cls, **kwargs: t.Any) -> None
```

Allow class-header keywords without raising TypeError.

**Arguments**:

- `**kwargs` - Arbitrary keywords from subclass declarations (e.g., type="Label").

#### \_\_str\_\_

```python
def __str__() -> str
```

Returns a string representation of the Context instance, including all field values.

**Returns**:

- `str` - String representation with all field values.

#### to\_gqlalchemy

```python
def to_gqlalchemy(db: "GraphDatabase") -> "gqlalchemy.Node"
```

Convert the Context object to a GQLAlchemy object.
!!! warning
    This method is not thread safe. We are actively working on a solution to make it thread safe.

#### from\_gqlalchemy

```python
@classmethod
def from_gqlalchemy(cls, gqlalchemy_node: "gqlalchemy.Node") -> "Context"
```

Convert a GQLAlchemy Node into a `Context` instance. If cls is the Context class itself, it will return the best subclass of Context that matches the labels of the GQLAlchemy Node.

**Arguments**:

- `gqlalchemy_node` - The GQLAlchemy Node to convert.
  

**Returns**:

  The converted Context or Context subclass instance.

#### save

```python
def save(db: "GraphDatabase")
```

Save the Context object to the graph database.

!!! warning
    This method is not thread safe. We are actively working on a solution to make it thread safe.

#### load

```python
def load(database: "GraphDatabase")
```

Loads a node from Memgraph.
If the node._id is not None it fetches the node from Memgraph with that
internal id.
If the node has unique fields it fetches the node from Memgraph with
those unique fields set.
Otherwise it tries to find any node in Memgraph that has all properties
set to exactly the same values.
If no node is found or no properties are set it raises a GQLAlchemyError.

#### chunk\_with

```python
def chunk_with(chunk_fn: t.Callable[["Context"], t.Iterable["Context"]],
               kwargs: t.Dict = {}) -> None
```

Chunks the context object into a list of context objects.

#### apply\_to\_chunks

```python
def apply_to_chunks(apply_fn: t.Callable[["Context"], None], **kwargs)
```

Applies apply_fn to each chunk in chunks.

**Arguments**:

- `apply_fn` - The function to apply to each chunk. Function should take in a Context object and mutate it.
- `**kwargs` - Additional keyword arguments to pass to apply_fn.

#### chunks

```python
@property
def chunks() -> t.List["Context"]
```

Returns the chunks of the context object.

#### is\_hydrated

```python
@property
def is_hydrated() -> bool
```

Returns True if the context object is hydrated.

#### model\_dump

```python
def model_dump(*,
               mode: str | Literal["json", "python"] = "python",
               include: IncEx | None = None,
               exclude: IncEx | None = None,
               context: Any | None = None,
               by_alias: bool | None = None,
               exclude_unset: bool = False,
               exclude_defaults: bool = False,
               exclude_none: bool = False,
               round_trip: bool = False,
               warnings: bool | Literal["none", "warn", "error"] = True,
               fallback: t.Callable[[Any], Any] | None = None,
               serialize_as_any: bool = False,
               include_hidden: bool = False) -> Any
```

Override of pydantics BaseModel.model_dump to allow for showing hidden fields

**Arguments**:

- `include_hidden` - Whether to show hidden fields.
  

**Returns**:

  The dictionary representation of the model.

#### model\_dump\_json

```python
def model_dump_json(*,
                    indent: int | None = None,
                    include: IncEx | None = None,
                    exclude: IncEx | None = None,
                    context: Any | None = None,
                    by_alias: bool | None = None,
                    exclude_unset: bool = False,
                    exclude_defaults: bool = False,
                    exclude_none: bool = False,
                    round_trip: bool = False,
                    warnings: bool | Literal["none", "warn", "error"] = True,
                    fallback: t.Callable[[Any], Any] | None = None,
                    serialize_as_any: bool = False,
                    include_hidden: bool = False) -> bytes | str
```

Override of pydantic's BaseModel.model_dump_json to allow for showing hidden fields

## Relation

```python
class Relation(Context, metaclass=RelationMeta)
```

Base class for all Relation objects.

#### truncate

```python
@model_validator(mode="wrap")
@classmethod
def truncate(cls, data: Any,
             handler: ValidatorFunctionWrapHandler) -> "Relation"
```

Truncates the start_node and end_node to their gqlalchemy ids.

#### get\_start\_node\_obj

```python
def get_start_node_obj(db: "GraphDatabase") -> Context
```

Get the start node object of the relation as a Context object.

**Arguments**:

- `db` - The GraphDatabase instance to use to fetch the start node.
  

**Returns**:

  The start node object as a Context object.

#### get\_end\_node\_obj

```python
def get_end_node_obj(db: "GraphDatabase") -> Context
```

Get the end node object of the relation as a Context object.

**Arguments**:

- `db` - The GraphDatabase instance to use to fetch the end node.
  

**Returns**:

  The end node object as a Context object.

#### \_\_str\_\_

```python
def __str__()
```

Returns a string representation of the Relation object, including all fields and their values.

**Returns**:

- `str` - String representation of the Relation object with all fields and their values.

#### to\_gqlalchemy

```python
def to_gqlalchemy(db: "GraphDatabase") -> "gqlalchemy.Relationship"
```

Convert the Context object to a GQLAlchemy object.

<Warning>Saves the start_node and end_node to the database if they are not already saved.</Warning>

<Danger>This method is not thread safe. We are actively working on a solution to make it thread safe.</Danger>

**Arguments**:

- `db` - The GraphDatabase instance to use to save the start_node and end_node if they are not already saved.
  

**Returns**:

  The GQLAlchemy Relationship object.
  

**Raises**:

- `AssertionError` - If db is not a modaic.databases.GraphDatabase instance.
- `ImportError` - If GQLAlchemy is not installed.

#### from\_gqlalchemy

```python
@classmethod
def from_gqlalchemy(cls,
                    gqlalchemy_rel: "gqlalchemy.Relationship") -> "Relation"
```

Convert a GQLAlchemy `Relationship` into a `Relation` instance. If `cls` is the `Relation` class itself, it will try to return an instance of a subclass of `Relation` that matches the type of the GQLAlchemy Relationship. If none are found it will fallback to an instance of `Relation` since the `Relation` class allows definiing inline.
If `cls` is instead a subclass of `Relation`, it will return an instance of that subclass and fail if the properties do not align.

**Arguments**:

- `gqlalchemy_obj` - The GQLAlchemy Relationship to convert.
  

**Raises**:

- `ValueError` - If the GQLAlchemy Relationship does not have the required fields.
- `AssertionError` - If the GQLAlchemy Relationship does not have the required type.
  

**Returns**:

  The converted Relation or Relation subclass instance.

#### save

```python
def save(db: "GraphDatabase")
```

Save the Relation object to the GraphDatabase.

!!! warning
    This method is not thread safe. We are actively working on a solution to make it thread safe.

#### load

```python
def load(db: "GraphDatabase")
```

Loads a relationship from GraphDatabase.
If the relationship._id is not None it fetches the relationship from GraphDatabase with that
internal id.
If the relationship has unique fields it fetches the relationship from GraphDatabase with
those unique fields set.
Otherwise it tries to find any relationship in GraphDatabase that has all properties
set to exactly the same values.
If no relationship is found or no properties are set it raises a GQLAlchemyError.

#### cast\_type\_if\_base\_model

```python
def cast_type_if_base_model(field_type)
```

If field_type is a typing construct, reconstruct it from origin/args.
If it's a Pydantic BaseModel subclass, map it to `dict`.
Otherwise return the type itself.

#### get\_ad\_hoc\_annotations

```python
def get_ad_hoc_annotations(rel: Relation)
```

Gets "adhoc" annotations for a Relation object. Specifically, for when Relations are created inline.
(i.e. when you do `Relation(x="test", _type="TEST_REL")`).
This is for those fields that were decleared inline.

**Arguments**:

- `rel` - The Relation object to get the adhoc annotations for.
  

**Returns**:

  A dictionary of the adhoc annotations.

#### with\_context\_vars

```python
def with_context_vars(**defaults)
```

Attach ContextVar-based caches to a class.

**Example**:

  @with_context_vars(user="guest", token=None)
  class Service: ...

## Hydratable

```python
@t.runtime_checkable
class Hydratable(t.Protocol)
```

#### from\_file

```python
@classmethod
def from_file(cls,
              file: str,
              file_store: FileStore,
              type: str,
              params: dict = None) -> "Hydratable"
```

Load a Hydratable instance from a file.

**Arguments**:

- `file` - The file to load.
- `file_store` - The file store to use.
- `type` - The type of file to expect.
- `params` - Extra parameters to pass to the constructor.

## Embeddable

```python
@t.runtime_checkable
class Embeddable(t.Protocol)
```

A protocol for objects that can be embedded. These objects define the embedme function which can either return a string or an image.
The embedme function can either take no args, or take an index name as an argument, which will be used to select the index to embed for.

## MultiEmbeddable

```python
@t.runtime_checkable
class MultiEmbeddable(t.Protocol)
```

A protocol for objects that can be embedded and have multiple embeddings. These objects define the embedme function which can either return a string or an image.
The embedme function can either take no args, or take an index name as an argument, which will be used to select the index to embed for.

