---
title: Graph Database
---
<Warning>This feature is experimental and is subject to change.</Warning>
<Danger>Writing to a graph database is not thread safe yet. We are actively working on a fix.</Danger>

Modaic provides a small, ergonomic ORM over [GQLAlchemy](https://memgraph.github.io/gqlalchemy/) to work with graph databases (Neo4j, Memgraph) using `Context` and `Relation` classes. This guide mirrors the style of our SQL guide and focuses on practical, copyâ€‘pasteable examples.


## Quickstart

### Install
If you plan to use the graph features, install the extra:
```bash
uv add "modaic[graph]"
```

Create a DB, define simple `Context`/`Relation` types, save nodes and relationships, and run Cypher.

```python
from modaic.databases import GraphDatabase, Neo4jConfig
from modaic.context import Context, Relation

# 1) Connect
db = GraphDatabase(Neo4jConfig())

# 2) Define Contexts (nodes)
class User(Context):
    name: str
    age: int

# 3) Save one
john = User(name="John", age=30)
db.save_node(john)

# 4) Save many
jane = User(name="Jane", age=25)
db.save_nodes([john, jane])

# 5) Define Relation (edge) with a custom type label
class FriendsWith(Relation, type="FRIENDS_WITH"):
    since: str

# 6) Relate nodes and save
rel = FriendsWith(since="2020-01-01")
john >> rel >> jane
db.save_relationship(rel)

# 7) Run Cypher and fetch results
rows = db.execute_and_fetch("MATCH (u:User) RETURN u LIMIT 2")
print(rows)  # list[dict], e.g., [{"u": <gqlalchemy.Node ...>}, ...]
```



## Backends
Create a database by instantiating a backend config and passing it to `GraphDatabase`.

### Neo4jConfig
```python
from modaic.databases import GraphDatabase, Neo4jConfig

# Custom parameters
config = Neo4jConfig(
    host="your_host",
    port=7687,
    username="your_username",
    password="your_password",
    encrypted=False,
    client_name="neo4j",
)

# Or defaults via env (NEO4J_*), see reference
config = Neo4jConfig()
db = GraphDatabase(config)
```

### MemgraphConfig
```python
from modaic.databases import GraphDatabase, MemgraphConfig

# Custom parameters
config = MemgraphConfig(
    host="your_host",
    port=7687,
    username="your_username",
    password="your_password",
    encrypted=False,
    client_name="memgraph",
    lazy=False,
)

# Or defaults via env (MG_*), see reference
config = MemgraphConfig()
db = GraphDatabase(config)
```

## Saving Nodes

### save_node
```python
node = User(name="Ria", age=28)
db.save_node(node)
```

### save_nodes
```python
users = [User(name="Ada", age=35), User(name="Lin", age=32)]
db.save_nodes(users)
```

## Saving Relationships

You can build relationships via sugar operators or by passing start/end nodes explicitly.

### save_relationship
```python
class ColleagueOf(Relation, type="COLLEAGUE_OF"):
    since: str

rel = ColleagueOf(since="2021-05-10")
ada = User(name="Ada", age=35)
lin = User(name="Lin", age=32)
ada >> rel >> lin
db.save_relationship(rel)
```

Alternatively:
```python
rel = ColleagueOf(start_node=ada, end_node=lin, since="2021-05-10")
db.save_relationship(rel)
```

### save_relationships
```python
rels = [
    ColleagueOf(start_node=ada, end_node=lin, since="2021-05-10"),
    ColleagueOf(start_node=lin, end_node=ada, since="2022-03-01"),
]
db.save_relationships(rels)
```

## Executing Cypher

Use raw Cypher for custom writes/reads.

### execute
Executes a statement without returning rows.
```python
db.execute("CREATE CONSTRAINT unique_user IF NOT EXISTS FOR (u:User) REQUIRE u.modaic_id IS UNIQUE")
```

You can also pass parameters:
```python
db.execute(
    "MATCH (u:User {name: $name}) SET u.age = $age",
    parameters={"name": "John", "age": 31},
)
```

### execute_and_fetch
Returns a list of dictionaries with selected variables.
```python
rows = db.execute_and_fetch("""
MATCH (u:User)
RETURN u
ORDER BY u.name
LIMIT 5
""")

# Optionally convert raw nodes to your Context class
from modaic.context import Context
users = [User.from_gqlalchemy(r["u"]) for r in rows]
```

## ORM Basics

- Context classes become node labels. If you pass `type="Label"` in the class header, that is used as the label; otherwise the class name is used.
- Relation classes become relationship types. Use `type="REL_TYPE"` similarly.
- The `>>`/`<<` operators are convenient sugar to set `start_node` and `end_node` before saving.
- Saving will create the underlying `gqlalchemy` objects and persist them.

Examples:
```python
class City(Context, type="CITY"):  # custom label
    name: str

class LocatedIn(Relation, type="LOCATED_IN"):
    pass

nyc = City(name="New York")
company = User(name="Acme", age=100)
company >> LocatedIn() >> nyc
db.save_relationship(LocatedIn(start_node=company, end_node=nyc))
```

## API Summary

- `GraphDatabase(config)`
  - Creates a client using either `Neo4jConfig` or `MemgraphConfig`.

- `save_node(node: Context) -> gqlalchemy.Node`
- `save_nodes(nodes: list[Context]) -> None`

- `save_relationship(relationship: Relation) -> gqlalchemy.Relationship | None`
- `save_relationships(relationships: list[Relation]) -> None`

- `execute(query: str, parameters: dict = {}, connection: Optional[gqlalchemy.Connection] = None) -> None`
- `execute_and_fetch(query: str) -> list[dict]`

<Danger>The save methods are not thread safe yet. Avoid concurrent writes to the same database from multiple threads or processes.</Danger>

## See also
- `modaic.context.base.Context` and `Relation` for the ORM model
- Reference pages for `modaic.databases.graph_database` configs