---
title: The Context Class
description: Guide to creating your own context classes
sidebarTitle: Context Class Intro
---

# The Context Class

Context is the currency of agents. In Modaic, this currency is minted by the `Context` class. `Context` extends `pydantic.BaseModel` with chunking, hydration, embedding, and graph helpers. Built-in contexts include `Text`/`TextFile` and `Table`/`TableFile`. See the [context library](/guides/context/context_library/index) for details.


## Serialization
### `model_dump(self)`
Same as a regular pydantic `BaseModel` but adds `include_hidden` to include fields marked with `hidden=True`.
```python
from pydantic import Field
from modaic.context import Context

class User(Context):
    name: str
    api_key: str = Field(hidden=True)

u = User(name="Ada", api_key="SECRET")
u.model_dump()
# {'name': 'Ada'}
u.model_dump(include_hidden=True)
# {'id': '...', 'parent': None, 'metadata': {}, 'name': 'Ada', 'api_key': 'SECRET'}
```
### `model_dump_json(self)`
This mirrors `model_dump` and returns JSON. It also supports `include_hidden`.
```python
u.model_dump_json()
u.model_dump_json(include_hidden=True)
```
### `schema(cls)`
This returns a simplified `modaic.Schema` that captures how the model will be serialized for databases.
```python
from modaic.context import Context
from modaic.types import Array, String

class Email(Context):
    subject: String[100]
    recipients: Array[str, 10]

Email.schema().as_dict()
# {'id': SchemaField(...), 'subject': SchemaField(...), 'recipients': SchemaField(...)}
```

## Chunking
### `chunk_with(self, fn: Callable[[Context], Iterable[Context]])`
Split any context into child contexts using a function that yields smaller contexts.
```python
from modaic.context import Text

t = Text(text="alpha beta gamma")
t.chunk_text(lambda s: s.split())  # convenience on Text
[c.text for c in t.chunks]
# ['alpha', 'beta', 'gamma']
```
### `apply_to_chunks(self, fn: Callable[[Context], None])`
Apply a function to each chunk to mutate or annotate them.
```python
t.apply_to_chunks(lambda c: c.metadata.update({"len": len(c.text)}))
[c.metadata["len"] for c in t.chunks]
# [5, 4, 5]
```
### `chunks`
Access the current list of chunks as an iterable.
```python
len(t.chunks)
```

## Hydration
### `hydrate(self, file_store: FileStore)`
Hydratable contexts load large data from a `FileStore` on demand to keep payloads small.
```python
from modaic.context import TableFile
from modaic.storage import InPlaceFileStore

store = InPlaceFileStore("tests/context/artifacts/test_dir")
table = TableFile.from_file_store("1st_New_Zealand_Parliament_0.xlsx", store)
table.is_hydrated  # True after from_file_store
```
### `is_hydrated`
This is `True` when all `HydratedAttr` fields are set.
```python
table.is_hydrated
```
### `Hydratable`
Use this protocol to detect hydratable objects. It checks for the presence of `hydrate(...)` and a compatible `from_file(...)` classmethod.
```python
from modaic.context import Hydratable, Text, TableFile
isinstance(Text(text="hi"), Hydratable)      # False
isinstance(table, Hydratable)                 # True
```

<Warning>`Hydratable` only checks method presence, not that the object is a `Context`. Use `modaic.context.is_hydratable(obj)` to check both.</Warning>


## Embedding and Vector Databases
Implement `embedme(...)` on contexts to provide strings or images for embedding. Multi-embedding contexts accept an index name.
### `embedme(self)`
```python
from modaic.context import Text
Text(text="hello").embedme()
# 'hello'
```
### `embedme(self, index: str)`
```python
from typing import Optional
from PIL import Image
from modaic.context import Context

class TwitterPost(Context):
    text: str
    image_url: str

    def embedme(self, index: Optional[str] = None):
        return self.text if index in (None, "text") else Image.new("RGB", (1, 1))
```


Use the `Embeddable` and `MultiEmbeddable` protocols to detect support.
```python
from modaic.context import Embeddable, MultiEmbeddable
isinstance(Text(text="hi"), Embeddable)          # True
isinstance(table, Embeddable)                      # True
isinstance(TwitterPost(text="t", image_url="u"), MultiEmbeddable)  # True
```

```python
isinstance(table, MultiEmbeddable)  # False
```

<Warning>These protocols check only method signatures. Use `is_embeddable(obj)` / `is_multi_embeddable(obj)` to ensure the object is a `Context` too.</Warning>


### Filters
Build filters from class-level properties using the Modaic query language. Compose with `|` and `&`.
```python
from modaic.context import Context
from modaic.types import Array, String

class Email(Context):
    subject: String[100]
    recipients: Array[str, 10]

f = (Email.recipients.contains("john@example.com") | Email.subject.contains("urgent"))
# pass f to your vector DB client
```


## Context Objects and Graph DBs
Install the graph extra to enable [gqlalchemy](https://memgraph.github.io/gqlalchemy/) integrations.
```bash
uv add modaic[graph]
```
### Context Objects as Nodes
#### `to_gqlalchemy(self, db: GraphDatabase)`
Convert a context to a `gqlalchemy.Node`. Labels default to the class name.
```python
from modaic.context import Context

class Employee(Context):
    name: str

# node = Employee(name="Ada").to_gqlalchemy(db)
```
Override labels by setting `type="CustomLabel"` on the class definition.
```python
class BaseEmployee(Context, type="Employee"): ...
```

#### `from_gqlalchemy(cls, node)`
Convert back to `Context` or the best-matching subclass based on labels.
```python
Employee.from_gqlalchemy(node)
Context.from_gqlalchemy(node)
```

<Tip>
Subclassing accumulates labels.
```python
class Employee(Context): ...
class Manager(Employee): ...
Manager() â†’ labels ['Employee', 'Manager']
```
</Tip>

#### `save(self, db)`
Persist a node via the `GraphDatabase` adapter.
```python
employee.save(db)
```

### Relation Objects
Relationships are `Relation` contexts with `start_node` and `end_node` references.
```python
from modaic.context import Relation, Context

class WorksAt(Relation):
    title: str
```

Convert relationships with `to_gqlalchemy`/`from_gqlalchemy`.
```python
rel.to_gqlalchemy(db)
```

#### `start_node_gql_id` and `end_node_gql_id`
Use these to access graph engine IDs for endpoints.

- Relations have two special methods: `get_start_node` and `get_end_node`.

#### `<<` and `>>` operators
Use these operators to set relation endpoints inline.
```python
alice >> WorksAt(title="Engineer") >> company
alice << WorksAt(title="Engineer") << company
```
<Warning>
You may think that doing
```python
alice << WorksAt(title="Engineer") >> company
```
creates an undirected relationship. But undirected relationships do not exists in graph databases.
Doing this will raise an error.
</Warning>

#### `save(self, db)`
Persist the relationship via `GraphDatabase`.
```python
rel.save(db)
```
