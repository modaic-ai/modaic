---
title: Tables
---

# Tables

The Table context classes provide a powerful way to work with structured tabular data in your agents. They wrap pandas DataFrames to make them compatible with the Context ecosystem, enabling vector storage, retrieval, and semantic operations. Tables can be stored directly in memory for smaller datasets or backed by files for larger ones. These classes are particularly useful for working with spreadsheets, CSV files, and any data that has a row-column structure.

## Table

The `Table` class represents an in-memory table backed by pandas DataFrames. It provides methods for querying, formatting, and extracting metadata from tabular data. This class is ideal for working with smaller datasets that can be fully loaded into memory and don't require file-based hydration.

```python
import pandas as pd
from modaic.context.table import Table

# Create a simple sales data table
df = pd.DataFrame({
    "Product": ["Laptop", "Phone", "Tablet", "Monitor"],
    "Price": [1200, 800, 350, 250],
    "Stock": [45, 120, 35, 28]
})

# Initialize the Table context
t = Table(df=df, name="inventory")

# Display as markdown
print(t.markdown())
# Output:
# Table name: inventory
# | Product | Price | Stock |
# | --- | --- | --- |
# | Laptop | 1200 | 45 |
# | Phone | 800 | 120 |
# | Tablet | 350 | 35 |
# | Monitor | 250 | 28 |

# Query expensive products
result = t.query("SELECT Product, Price FROM this WHERE Price > 500")
print(result)
# Output:
#   Product  Price
# 0  Laptop   1200
# 1   Phone    800
```

## TableFile

The `TableFile` class represents a table backed by a file in a `FileStore`. It uses hydration to load data on demand, making it suitable for larger datasets or when you want to avoid storing the entire table in vector databases. This class supports Excel files (xls/xlsx), CSV files, and TSV files.

```python
from modaic.context.table import TableFile
from modaic.storage import InPlaceFileStore

# Set up a file store pointing to your data directory
store = InPlaceFileStore("data/spreadsheets")

# Create a TableFile that references an Excel file
tf = TableFile.from_file_store("quarterly_sales.xlsx", store)

# Access the data only when needed (triggers hydration)
print(f"Table contains {len(tf._df)} rows and {len(tf._df.columns)} columns")
# Output: Table contains 250 rows and 8 columns

# Generate markdown representation
sales_markdown = tf.markdown()
print(sales_markdown[:150])  # Print first 150 chars
# Output:
# Table name: quarterly_sales
# | Quarter | Region | Product | Sales | Revenue | Costs | Profit | Growth |
# | --- | --- | --- | --- | --- | --- | --- | --- |
```

## Table Methods

### `column_samples(col)`

Returns up to 3 distinct, non-null sample values from the specified column to help understand the data distribution.

```python
samples = t.column_samples("Product")
print(samples)
# Output: ['Laptop', 'Phone', 'Tablet']
```

### `get_col(name)`

Retrieves a single column from the table as a pandas Series, allowing for further pandas operations.

```python
prices = t.get_col("Price")
print(prices.mean())
# Output: 650.0
```

### `schema_info()`

Returns a dictionary with table name and column metadata including types and sample values, useful for understanding table structure.

```python
schema = t.schema_info()
print(schema["table_name"])
# Output: inventory
print(schema["column_dict"]["Product"]["type"])
# Output: VARCHAR
print(schema["column_dict"]["Price"]["sample_values"])
# Output: [1200, 800, 350]
```

### `query(sql)`

Executes a DuckDB SQL query against the in-memory table (referenced as `this`), enabling powerful data filtering and aggregation.

```python
# Find average price by product category
summary = t.query("""
    SELECT 
        CASE 
            WHEN Price > 1000 THEN 'Premium'
            WHEN Price > 500 THEN 'Mid-range'
            ELSE 'Budget'
        END AS Category,
        AVG(Price) AS AvgPrice,
        COUNT(*) AS Count
    FROM this
    GROUP BY Category
""")
print(summary)
# Output:
#    Category  AvgPrice  Count
# 0   Premium    1200.0      1
# 1  Mid-range     800.0      1
# 2     Budget     300.0      2
```

### `markdown()`

Generates a human-readable markdown representation of the table with headers and rows, perfect for displaying in documentation or agent responses.

```python
md = t.markdown()
print(md)
# Output:
# Table name: inventory
# | Product | Price | Stock |
# | --- | --- | --- |
# | Laptop | 1200 | 45 |
# | Phone | 800 | 120 |
# | Tablet | 350 | 35 |
# | Monitor | 250 | 28 |
```

### `embedme()`

Returns the table's markdown representation for embedding, making the table content available for vector search and semantic operations.

```python
embedding_text = t.embedme()
# Pass to embedding model
# vector = embedder.embed(embedding_text)
```

### `to_text()`

Converts the table to a `Text` context object containing the markdown representation, allowing you to perform chunking and other text-based operations on tabular data.

```python
text_context = t.to_text()
print(type(text_context).__name__)
# Output: Text
print(text_context.text[:20])
# Output: Table name: inventory
```