# Guide to Defining Your Own Context Classes

## The `Context` Class
- is a subclass of `BaseModel`
- anything you can do with a `BaseModel` you can do with a `Context` + more
## Types and fields
- can use regular types
- Context classes can be converted to modaic.Schemas
- However, modaic.Schema enforces some rules,
  - Cannot have Union types unless it is Union[..., None]
  - Cannot have Literals with different types
  - Must be serializable python objects
  - Cannot have List of different types
### Specific Dtypes
#### `Array`
#### `String`
#### ints and floats
!!! note you do not have to use the specific dtypes. Regular python types are supported. However, dtypes can be useful for vectordatabase backends that optimize indexes based on a strict payload structure.

### Hiding and Excluding Fields
- Field(exclude=True) -> will never be serialized. Won't be inserted into payloads of vector or graph databases. You must keep track of the field to intialize the context object later.
   !!! warning. If you want to specify a field that is not serialized consider using PrivateAttr instead. This will make it so the field also doesnt appear in the constructor as well.
- Field(hidden=True) -> Hidden to dspy and llms and other external libraries that serialize the context object. Not hidden to modaic and will still be serialized when inserted into vector or graph databases.

## Adding functions to your context object
- Context objects are not regular python objects. They are pydantic models.
- you cannot define an __init__ method or you will get very unexpected behavior.
- instead you set initilization logic via pydantic validators.
- @field_validator - operates on class methods. keywords before and after are used to specify whether the function runs before or after pydantic validates the data in the constructor.
- @model_validator - operates on instance methods and therefore has access to `self`. keywords after is used to specify whether the function runs after pydantic validates the data in the constructor.


## Working with Files - HydratedAttr
- Sometimes a context object contains too much data for it all to be stored in a vector or graph database. In these cases, the large data is stored as a file else where and the context oject holds a reference to it. 
- When the context object is fetched it can load its associated file into memory for further processing. We call this hydration.
Fields that store data that comes from those files are marked with `HydratedAttr`
- you must also implement the `hydrate` method to load the file into memory.
- all functions that use the hydrated attribute must use the `requires_hydration` decorator. This will raise an error if the attribute is not hydrated.

## Python objects in your context object - PrivateAttr
### Non serializable python objects
- Sometimes you may need to include non serializable python objects in your context object.
- for example an image

### Serializeble python objects
- another example is the Table class which stores a pandas dataframe. The data frame is serialized as a list of dictionaries to a public attribute and the object is stored as a PrivateAttr.
- to 