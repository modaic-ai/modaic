---
title: Custom Context Classes
---

# Guide to Defining Your Own Context Classes

This guide will walk you through the process of creating your own custom Context classes in Modaic. By defining your own Context classes, you can model domain-specific data structures while gaining access to all the powerful features of the Context ecosystem, including chunking, hydration, embedding, and graph database integration.

## The `Context` Class

The `Context` class is a specialized subclass of `pydantic.BaseModel` that adds several powerful capabilities for agent-based systems. It inherits all the validation, serialization, and type checking features from Pydantic while extending them with additional functionality for semantic operations. When creating your own Context classes, you should always inherit from `Context` rather than directly from `BaseModel` to ensure compatibility with the Modaic ecosystem.

Unlike regular Python classes, Context objects follow Pydantic's initialization patterns. This means you should never define a custom `__init__` method, as doing so will interfere with Pydantic's validation system. Instead, use Pydantic's validator decorators to customize initialization behavior. This approach ensures that your Context classes maintain compatibility with the broader ecosystem.

## Types and Fields

When defining fields in your Context classes, you can use standard Python types just as you would in any Pydantic model. The `Context.schema()` method will convert your class definition into a `modaic.Schema` object that describes the structure for database payloads. This schema representation is particularly important for vector databases that need to understand the structure of your data.

There are several important rules to follow when defining fields in your Context classes:

1. Union types are only allowed in the form of `Optional[T]` (equivalent to `Union[T, None]`). Other union types are not supported in the schema representation.

2. All fields must be JSON-serializable to ensure they can be properly stored and retrieved from databases. Complex objects should be handled with `PrivateAttr` or `HydratedAttr` (discussed later).

3. Arrays (lists) must be homogeneous, containing only elements of the same type. Heterogeneous lists are not supported in the schema representation.

4. When using `Literal` types, all possible values must be of the same type (e.g., all strings or all integers, not a mix).

### Modaic Types

Modaic provides specialized type annotations in the `modaic.types` module that help constrain field values for database backends. These types add metadata that vector databases can use to optimize storage and indexing.

#### `Array`

The `Array` type is an annotated list that allows you to specify both the element type and the maximum size. This is particularly useful for vector databases that need to allocate fixed-size arrays.

```python
from modaic.types import Array
from modaic.context import Context

class Email(Context):
    content: str
    recipients: Array[str, 100]  # A list of strings with max 100 elements
```

When you use `Array[dtype, max_size]`, Pydantic will validate that the list contains only elements of the specified type and that it doesn't exceed the maximum size. This validation happens at object creation time, preventing invalid data from entering your system.

#### `String`

The `String` type is a parameterized string that allows you to specify a maximum length constraint. This is useful for databases that need to allocate fixed-size string fields.

```python
from modaic.types import String
from modaic.context import Context

class Email(Context):
    subject: String[100]  # A string with max 100 characters
    content: str
    recipients: Array[str, 100]
```

The `String[max_length]` type will be validated by Pydantic to ensure that strings don't exceed the specified maximum length. If you try to create an Email with a subject longer than 100 characters, Pydantic will raise a validation error.

<Tip>
While these specialized types provide additional constraints for database optimization, you can still use standard Python types like `str` and `list[T]` in your Context classes. Pydantic will handle the validation, and the vector database will configure appropriate storage based on the actual data.
</Tip>

#### Integers and Floats

Modaic provides specialized integer and float types with specific bit widths, such as `int8`, `int16`, `int32`, `int64`, and `double`. These types can be useful when you need precise control over the numeric representation in database backends.

<Note>
In most cases, using standard Python `int` and `float` types is sufficient. The specialized numeric types are primarily useful when working with database backends that have specific schema requirements or when you need to enforce value ranges.
</Note>

### Hiding and Excluding Fields

Context classes provide two ways to control field serialization:

`Field(exclude=True)` marks a field to be completely excluded from serialization. These fields will never be included in the serialized representation and won't be inserted into database payloads. This is useful for fields that are only needed during processing but shouldn't be persisted.

<Warning>
If you need a field that's used only within Python code and never serialized, consider using `PrivateAttr` instead of `Field(exclude=True)`. The `PrivateAttr` approach has the advantage of not appearing in the constructor arguments, making the API cleaner.
</Warning>

`Field(hidden=True)` marks a field as hidden from default serialization, but it can still be included when explicitly requested. Hidden fields are excluded when serializing for external libraries like DSPy or LLMs, but they are included when serializing for Modaic's internal use and database storage. You can access hidden fields by using `model_dump(include_hidden=True)` or `model_dump_json(include_hidden=True)`.

Hidden fields are particularly useful for:
- IDs, references, and metadata that would clutter the context window when working with LLMs
- Personally identifiable information (PII) that shouldn't be exposed to external systems
- Technical fields that aren't relevant to the semantic content

## Adding Functions to Your Context Object

You can add custom methods to your Context classes just like any Python class. However, for initialization and validation logic, you should use Pydantic's validator decorators rather than defining a custom `__init__` method.

The `@field_validator` decorator is used to validate or transform individual fields. When using `mode="before"`, the validator runs before Pydantic's type validation, allowing you to normalize or preprocess input values.

```python
from pydantic import field_validator
from modaic.context import Context

class User(Context):
    username: str
    
    @field_validator("username", mode="before")
    @classmethod
    def normalize_username(cls, v):
        return v.lower().strip()  # Normalize username to lowercase and remove whitespace
```

The `@model_validator` decorator operates on the entire model, either before or after Pydantic's validation. It's particularly useful for setting up private attributes or performing cross-field validation.

- Use `mode="wrap"` to completely control the validation process, including setting private attributes
- Use `mode="after"` when you need to access the fully validated model instance

```python
from pydantic import model_validator
from modaic.context import Context

class Profile(Context):
    first_name: str
    last_name: str
    _full_name: str = PrivateAttr()
    
    @model_validator(mode="after")
    def set_full_name(self):
        self._full_name = f"{self.first_name} {self.last_name}"
        return self
```

## Making Your Context Object Embeddable

To make your Context class compatible with vector databases, you need to implement the `embedme` method. This method returns the content that should be passed to an embedding model to generate vector representations of your context objects.

The vector database looks for this method when adding records to collections. There are two ways to implement `embedme`, depending on whether your context has a single embedding or multiple embeddings.

For context objects with a single embedding source:

```python
class TwitterPost(Context):
    text: str
    author: str
    timestamp: datetime
    
    def embedme(self) -> str:
        """Return the text content for embedding."""
        return self.text
```

For context objects that support multiple embeddings (useful for hybrid search or multi-modal models), add an optional `index` parameter:

```python
from typing import Optional
from PIL import Image
from modaic.context import Context, HydratedAttr, requires_hydration

class TwitterPost(Context):
    text: str
    image_url: str
    _image: Optional[Image.Image] = HydratedAttr()
    
    @requires_hydration
    def embedme(self, index: Optional[str] = None) -> str | Image.Image:
        """Return either text or image content based on the index."""
        if index == "text":
            return self.text
        elif index == "image":
            return self._image
        else:
            # Always include a default case
            return self.text
```

When implementing `embedme` with an index parameter, always include a default case that handles `None` or unrecognized index values. This ensures that your context can be embedded even when no specific index is requested.

## Working with Complex Python Objects - PrivateAttr

Sometimes you need your Context object to store complex Python objects from libraries or internal modules that aren't directly serializable. These objects can provide additional functionality but shouldn't be part of the serialized representation.

In Modaic, the common pattern is to store:
1. A serialized version as a regular Pydantic field (for persistence)
2. The actual object as a `PrivateAttr` (for in-memory operations)

All `PrivateAttr` fields must be prefixed with an underscore to distinguish them from regular fields. The `Table` class demonstrates this pattern by storing a pandas DataFrame:

```python
from typing import Any, Dict, List
from pydantic import Field, PrivateAttr, model_validator
import pandas as pd
from modaic.context import Context

class Table(Context):
    content: str = ""
    df: List[Dict[str, Any]] = Field(hidden=True)  # Serializable representation
    _df: pd.DataFrame = PrivateAttr()  # Non-serializable object for operations
    
    @model_validator(mode="wrap")
    @classmethod
    def initialize_dataframe(cls, data: Any, handler: ValidatorFunctionWrapHandler) -> "Table":
        df = data["df"]
        if isinstance(df, pd.DataFrame):
            # If a DataFrame is provided, serialize it for storage
            serialized_df = df.to_dict(orient="records")
            pd_df = df
        else:
            # If serialized data is provided, deserialize it
            serialized_df = df
            pd_df = pd.DataFrame(serialized_df)
            
        # Update the data with the serialized version
        data["df"] = serialized_df
        
        # Initialize the instance
        self = handler(data)
        
        # Set the private attribute with the DataFrame object
        self._df = pd_df
        return self
```

The `@model_validator(mode="wrap")` decorator is particularly useful for initializing private attributes, as it gives you complete control over the validation process and access to both the input data and the initialized instance.

## Working with Files - HydratedAttr

While `PrivateAttr` works well for small serializable objects, vector and graph databases have storage limits and cost considerations that make them unsuitable for large data. For larger objects like images, audio files, or large datasets, Modaic provides the concept of hydration.

Hydration is a pattern where:
1. You store a reference to external data (like a file path or URL) in your serialized Context
2. You load the actual data on demand when needed

The `HydratedAttr` field type marks attributes that should be initialized from external files. Unlike regular attributes, `HydratedAttr` fields:
- Are always initialized to `None` by default
- Are populated only when explicitly hydrated
- Are not serialized with the Context object

To implement hydration in your Context class:

1. Define fields that should be hydrated using `HydratedAttr()`
2. Implement a `hydrate(self, file_store: FileStore)` method that loads data from files
3. Decorate methods that require hydrated data with `@requires_hydration`

Here's an example of a `TableFile` class that uses hydration to load data from spreadsheet files:

```python
from typing import Literal, Optional, IO
from pathlib import Path
import pandas as pd
from pydantic import Field
from modaic.context import Context, HydratedAttr, requires_hydration
from modaic.storage.file_store import FileStore

class TableFile(Context):
    """A Context object to represent table documents such as excel, csv and tsv files."""
    
    file_ref: str  # Reference to the file in a FileStore
    file_type: Literal["xls", "xlsx", "csv", "tsv"]
    sheet_name: Optional[str] = None
    _df: Optional[pd.DataFrame] = HydratedAttr()  # Will be loaded on demand
    
    def hydrate(self, file_store: FileStore) -> None:
        """Load the DataFrame from the referenced file."""
        file = file_store.get(self.file_ref)
        self._hydrate_from_file(file)
    
    def _hydrate_from_file(self, file: Path | IO) -> None:
        """Internal method to load data based on file type."""
        if self.file_type in ["excel", "xlsx"]:
            if self.sheet_name is None:
                df = pd.read_excel(file)
            else:
                df = pd.read_excel(file, sheet_name=self.sheet_name)
        elif self.file_type == "csv":
            df = pd.read_csv(file)
        elif self.file_type == "tsv":
            df = pd.read_csv(file, sep="\t")
        else:
            raise ValueError(f"Unsupported file type: {self.file_type}")
            
        self._df = df  # Store the loaded DataFrame
    
    @requires_hydration
    def markdown(self) -> str:
        """Convert the table to markdown format. Requires hydration."""
        content = f"Table name: {self.name}\n"
        
        # Add header row
        columns = [str(col) for col in self._df.columns]
        content += "| " + " | ".join(columns) + " |\n"
        
        # Add header separator
        content += "| " + " | ".join(["---"] * len(columns)) + " |\n"
        
        # Add data rows
        for _, row in self._df.iterrows():
            row_values = []
            for value in row:
                if pd.isna(value) or value is None:
                    row_values.append("")
                else:
                    row_values.append(str(value))
            content += "| " + " | ".join(row_values) + " |\n"
            
        return content
```

The `@requires_hydration` decorator is crucial for methods that depend on hydrated attributes. It checks if all hydrated attributes are set before executing the method, raising a clear error if the context hasn't been hydrated yet.

<Info>
Hydration can be used for various types of external data. For example, in a TwitterPost context that includes images:

```python
class TwitterPost(Context):
    text: str
    image_url: str
    _image: Optional[Image.Image] = HydratedAttr()
    
    def hydrate(self, file_store: FileStore):
        """Load the image from the referenced URL."""
        image_file = file_store.get(self.image_url)
        self._image = Image.open(image_file)
        
    @requires_hydration
    def get_image_dimensions(self) -> tuple[int, int]:
        """Return the dimensions of the image (requires hydration)."""
        return self._image.size
```
</Info>

By combining regular fields, private attributes, and hydrated attributes, you can create Context classes that efficiently represent complex data structures while maintaining compatibility with the Modaic ecosystem.